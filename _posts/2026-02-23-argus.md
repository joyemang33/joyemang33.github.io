---
layout: post
title: "Argus: Automated Discovery of Test Oracles for Database Management Systems Using LLMs"
date: 2026-02-23
author: "Qiuyang Mang, Runyuan He, Suyang Zhong, Xiaoxuan Liu, Huanchen Zhang, Alvin Cheung"
description: We present Argus, a novel framework that uses LLMs to automatically discover test oracles for DBMS testing ‚Äî finding 41 previously unknown bugs across 5 widely-used databases. Accepted at SIGMOD 2026.
tags: [database, testing, LLM, SQL, Auto Discovery]
categories: research
related_posts: false
toc:
  sidebar: left
---

---

### TL;DR

Database Management Systems (DBMSs) are notoriously hard to test because you need a *test oracle* ‚Äî a way to know if the output is correct. Prior work builds these oracles **by hand**, creating a never-ending cycle of manual effort.

**Argus** breaks this cycle by using LLMs to *automatically discover* test oracles, then formally *verifies* them with a SQL equivalence prover for soundness, and efficiently *instantiates* them into thousands of concrete test cases. Evaluated on five heavily-tested DBMSs, Argus found **41 previously unknown bugs** (36 logic bugs), outperforming state-of-the-art manual oracle designs.

---

### The Problem: Test Oracles Are a Bottleneck

<img src="https://joyemang33.github.io/assets/img/argus-1.png" alt="Test Oracle Problem" style="max-width: 75%; display: block; margin: 1rem auto;">

When testing a DBMS, how do you know if the result of a SQL query is *correct*? This is the **test oracle problem**. A naive approach would be to compare two DBMSs against each other, but that misses bugs they share. The dominant approach instead builds *semantic equivalence oracles*: transform a query $$Q$$ into a semantically equivalent $$Q'$$, run both, and flag inconsistencies as bugs.

The catch: **designing such transformation mechanisms is entirely manual**. Researchers have published over 20 top-conference papers, each hand-crafting specialized oracles ‚Äî [`TLP`](https://dl.acm.org/doi/10.1145/3428279), [`NoREC`](https://dl.acm.org/doi/10.1145/3368089.3409710), [`EET`](https://www.usenix.org/conference/osdi24/presentation/jiang-zu-ming), [`DQP`](https://dl.acm.org/doi/10.1145/3654990) ‚Äî yet bugs keep slipping through. Consider this real TiDB bug that went undetected for *years*:

```sql
CREATE TABLE t1(c INT);
INSERT INTO t1 VALUES (1);

-- Q: Empty table filter ‚Üí should return {}
SELECT c / 3 FROM t1 WHERE false;       -- {} ‚úì

-- Oracle: Q EXCEPT Q should always be empty
SELECT c / 3 FROM t1 EXCEPT SELECT c / 3 FROM t1;  -- {0.3333} ‚úó (BUG!)
```

Catching this required the very specific insight that $$Q \setminus Q = \emptyset$$. A human had to think of it. Can we make a machine do that automatically?

---

### Key Insight: Constrained Abstract Queries (CAQ)

The core innovation in Argus is a new representation called a **Constrained Abstract Query (CAQ)** ‚Äî a SQL query template with typed *placeholders* that can be filled with concrete SQL snippets.

A placeholder $$\square_i$$ can be either:
- **`Expr(TableName : SQLDatatype)`** ‚Äî any expression over a table that returns a given type (e.g., a Boolean expression over `t1`)
- **`Table(SQLTableDef)`** ‚Äî any table or subquery with a given schema

An **equivalent CAQ pair** $$(s, q_1, q_2)$$ is two CAQs that produce the *same results for every possible instantiation* of their placeholders. For example, the classic **TLP oracle** can be expressed as a CAQ pair:

```sql
-- Q‚ÇÅ: seed query
SELECT * FROM t1, ‚ñ°‚ÇÅ‚ä≤Table(...);

-- Q‚ÇÇ: TLP three-way partition
SELECT * FROM t1, ‚ñ°‚ÇÅ‚ä≤Table(...) WHERE (‚ñ°‚ÇÇ‚ä≤Expr(t1:BOOLEAN) IS TRUE)
UNION ALL
SELECT * FROM t1, ‚ñ°‚ÇÅ‚ä≤Table(...) WHERE (‚ñ°‚ÇÇ‚ä≤Expr(t1:BOOLEAN) IS FALSE)
UNION ALL
SELECT * FROM t1, ‚ñ°‚ÇÅ‚ä≤Table(...) WHERE (‚ñ°‚ÇÇ‚ä≤Expr(t1:BOOLEAN) IS NULL);

-- Instantiation examples:
-- ‚ñ°‚ÇÅ ‚Ü¶ t1 ASOF JOIN t2
-- ‚ñ°‚ÇÇ ‚Ü¶ json_valid(t1.c0)
```

The power of CAQs: one CAQ pair is a reusable oracle that can generate *thousands* of concrete test cases by filling its placeholders with diverse SQL snippets.

---

### The Argus Pipeline

<img src="https://joyemang33.github.io/assets/img/argus-2.png" alt="Overall pipeline of Argus" style="max-width: 90%; display: block; margin: 1rem auto;">

Argus operates in two stages:

#### Stage 1 ‚Äî Test Oracle Discovery (offline, one-time)

**‚ë† Database Seeding.** A grammar-based generator ([`SQLancer`](https://github.com/sqlancer/sqlancer)) produces random database schemas and seed CAQs. Virtual columns and tables serve as placeholders, making the output compatible with SQL provers that expect concrete syntax.

**‚ë° LLM-based Oracle Generation + Formal Verification.** For each seed CAQ $$q$$, Argus iteratively prompts an LLM to generate an equivalent variant $$q'$$. Two mechanisms ensure quality:

- **In-context learning** ‚Äî the LLM is shown verified successes (*Equal* set) and failures (*Fail* set) from previous rounds.
- **Diversity-oriented sampling** ‚Äî verified CAQs are clustered by query-plan tree-edit distance (k-means), and samples are drawn from each cluster to push the LLM toward novel execution plans.

Every candidate $$q'$$ must pass a **SQL equivalence prover** (`SQLSolver`) before acceptance. Placeholders are replaced by virtual entities so the prover can reason on concrete queries. Only formally verified pairs become test oracles ‚Äî **zero false positives by design**.

#### Stage 2 ‚Äî Test Case Instantiation (online, per DBMS)

**‚ë¢ Corpus Synthesis.** A hybrid approach (LLM + grammar-based generator) pre-generates a large library of SQL snippets:
- LLMs produce *complex, feature-rich* expressions and table structures, guided by official DBMS documentation.
- The grammar-based generator covers *corner values and edge cases* systematically.
- **Cross-combination**: expressions are recursively composed (e.g., substituting a `Boolean` expr into an `INT` function that expects a Boolean column) to create intricate multi-level expressions.
- Every snippet is *runtime-validated* on the target DBMS to filter type mismatches and invalid SQL.

**‚ë£‚ë§‚ë• Instantiation & Bug Detection.** Each verified CAQ pair is instantiated up to $$K$$ times by randomly sampling compatible snippets from the corpus. Placeholders are replaced consistently in both $$q$$ and $$q'$$. Random database instances are created, and the two queries are executed. Any result mismatch is a bug report.

Three *general constraints* on snippets guarantee that instantiated pairs remain equivalent even when concrete expressions are plugged in:
1. **Determinism** ‚Äî no `RANDOM()`, `CURRENT_TIMESTAMP`, etc.
2. **Null-preserving** ‚Äî expression returns `NULL` when evaluated on all-`NULL` rows.
3. **Empty-result-preserving** ‚Äî expression returns empty on an empty table.

---

### Representative Bugs Found

<p style="font-size: 1rem; font-weight: 700; margin-bottom: 0.3rem;">üìå PostgreSQL: Incorrect json function in RIGHT JOIN</p>

```sql
CREATE TABLE t(c INT);
INSERT INTO t VALUES (1);

-- Q1: RIGHT JOIN with FALSE ‚Üí left side always NULL
SELECT sub.c FROM (
  SELECT json_array_length(json_array(3, 2, t.c)) AS c FROM t
) AS sub RIGHT JOIN t ON FALSE;  -- Expected: {NULL}, Got: {2} ‚úó

-- Q2: explicitly NULL in subquery
SELECT sub.c FROM (SELECT NULL AS c FROM t) AS sub
RIGHT JOIN t ON FALSE;  -- {NULL} ‚úì
```

**Root cause:** PostgreSQL's json functions bypass the null-propagation rule for `RIGHT JOIN`, producing incorrect non-null values. Reported and fixed within **24 hours**.

<p style="font-size: 1rem; font-weight: 700; margin-bottom: 0.3rem;">üìå Dolt: EXISTS duplicates rows</p>

```sql
CREATE TABLE t(c0 INT, c1 INT, PRIMARY KEY (c0, c1));
INSERT INTO t VALUES (1,1), (2,2), (2,3);

-- With NOT NULL primary key, EXISTS is always TRUE ‚Üí should return all rows once
SELECT * FROM t WHERE EXISTS (SELECT 1 FROM t AS x WHERE x.c0 = t.c0);
-- Got: {(1,1),(2,2),(2,3),(1,1),(2,2),(2,3)} ‚úó ‚Äî every row duplicated!

SELECT * FROM t;  -- {(1,1),(2,2),(2,3)} ‚úì
```

<p style="font-size: 1rem; font-weight: 700; margin-bottom: 0.3rem;">üìå DuckDB: Empty CTE incorrectly short-circuits UNION ALL</p>

```sql
-- Q1
SELECT t2.c0 FROM t2, t3 LEFT JOIN t1 ON false;  -- {true} ‚úì

-- Q2 (equivalent via CTE expansion)
WITH c AS (SELECT * FROM t1 WHERE false)
SELECT t2.c0 FROM t2 CROSS JOIN t3 CROSS JOIN c
UNION ALL
SELECT t2.c0 FROM t2 CROSS JOIN t3 WHERE NOT EXISTS (SELECT 1 FROM c);
-- Got: {0 rows} ‚úó
```

**Root cause:** DuckDB incorrectly assumes an empty materialized CTE always causes the outer query to return no rows ‚Äî not true with `UNION ALL`.

---

### Evaluation Results

#### Bugs Found (5 DBMSs, 2-month campaign)

<table class="table table-sm text-center" style="width: auto; margin: 1rem auto 2rem; font-family: 'Open Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; font-size: 0.88rem; border: 1px solid #ccc; color: var(--global-text-color);">
  <thead style="background-color: #f0f0f0; font-weight: 600;">
    <tr>
      <th class="text-start" style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px; color: var(--global-text-color);">DBMS</th>
      <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px; color: var(--global-text-color);">Reported</th>
      <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px; color: var(--global-text-color);">Fixed</th>
      <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px; color: var(--global-text-color);">Confirmed</th>
      <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px; color: var(--global-text-color);">Logic Bugs</th>
    </tr>
  </thead>
  <tbody>
    <tr><td class="text-start" style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">Dolt</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">19</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">18</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">19</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">18</td></tr>
    <tr><td class="text-start" style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">DuckDB</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">8</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">6</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">7</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">4</td></tr>
    <tr><td class="text-start" style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">MySQL</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">8</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">0</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">5</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">8</td></tr>
    <tr><td class="text-start" style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">PostgreSQL</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">1</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">1</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">1</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">1</td></tr>
    <tr><td class="text-start" style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">TiDB</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">5</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">2</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">5</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">5</td></tr>
    <tr style="font-weight: 700; border-top: 2px solid #ccc;"><td class="text-start" style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">Total</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">41</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">27</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">36</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">36</td></tr>
  </tbody>
</table>

<!-- </br> -->
36 out of 41 bugs are **logic bugs** ‚Äî the silent, most dangerous class that cause incorrect query results without any error. Compared to recent works with manually crafted oracles, Argus finds *more* despite targeting DBMSs already extensively tested.

#### Code Coverage

<!-- üì∏ IMAGE PLACEHOLDER 6
     Âª∫ËÆÆ: ÊèíÂÖ• paper ‰∏≠ÁöÑ Figure 3 "Code coverage" ÂõõÊ†ºÂõæÔºàDuckDB line/branchÔºåPostgreSQL line/branchÔºâÔºå
     Â±ïÁ§∫ Argus vs SQLancer vs SQLancer++ vs EET Âú® 24 Â∞èÊó∂ÊµãËØï‰∏≠ÁöÑ line/branch coverage Êõ≤Á∫ø„ÄÇ
     ËøôÊòØ coverage ÂØπÊØîÁöÑÊ†∏ÂøÉÂõæ„ÄÇ
-->

On **DuckDB** (24-hour run):
- Argus achieves **+19.9% line coverage** and **+18.1% branch coverage** over `SQLancer++`
- **5.5√ó line** and **6.4√ó function** [metamorphic coverage](https://arxiv.org/abs/2508.16307) over `SQLancer` ‚Äî *metamorphic coverage* measures how much code is exercised *differently* between the two equivalent queries, directly correlating with logic bug-finding ability

On **PostgreSQL**:
- Outperforms `SQLancer++` by **+19.0% line** and **+22.5% branch** coverage
- Covers **23 query features** (vs `SQLancer`'s 15 in `pglast`), demonstrating the LLM's ability to generate feature-rich queries

#### New Oracles vs. Prior Manual Oracles

<!-- üì∏ IMAGE PLACEHOLDER 7
     Âª∫ËÆÆ: ÊèíÂÖ• paper ‰∏≠ÁöÑ Figure 4ÔºåÂ±ïÁ§∫Âú® Dolt v1.0.0 ‰∏ä 6 Â∞èÊó∂ÊµãËØï‰∏≠
     Argus-5000 / Argus-50 / BaselineÔºàTLP+NoREC+EET+DQP ÂÖ± 11 ‰∏™ÊâãÂ∑• oracleÔºâ
     ÊâæÂà∞ÁöÑ unique logic bugs Êï∞ÈáèÈöèÊó∂Èó¥ÁöÑÂèòÂåñÊõ≤Á∫ø„ÄÇ
     Argus-5000 ÊâæÂà∞ 10 ‰∏™Ôºåbaseline Âè™ÊâæÂà∞ 3 ‰∏™„ÄÇ
-->

In a head-to-head comparison on Dolt v1.0.0 (6-hour window), using **the same snippet corpus and CAQ format** for fairness:
- **Argus-5,000 oracles**: found **10 unique logic bugs**
- **Baseline** (union of [`TLP`](https://dl.acm.org/doi/10.1145/3428279) + [`NoREC`](https://dl.acm.org/doi/10.1145/3368089.3409710) + [`EET`](https://www.usenix.org/conference/osdi24/presentation/jiang-zu-ming) + [`DQP`](https://dl.acm.org/doi/10.1145/3654990) ‚Äî 11 hand-crafted oracles): found **3**
- Argus-50 oracles (fewer than baseline): found only 2, confirming the *quantity* of oracles matters

The **3.33√ó improvement** demonstrates that automation unlocks oracle diversity that manual design simply cannot match at scale.

#### Cost & Efficiency

<!-- üì∏ IMAGE PLACEHOLDER 8
     Âª∫ËÆÆ: ÊèíÂÖ• paper ‰∏≠ÁöÑ Figure 5 "Cost and efficiency comparison"Ôºå
     ÊòæÁ§∫ ArgusÔºàPhase I CAQ ÁîüÊàê + Phase II ÂÆû‰æãÂåñÔºâvs Êú¥Á¥† baseline Âú® 1 Â∞èÊó∂ÂÜÖ
     Á¥ØËÆ°ÁîüÊàê test case Êï∞ÈáèÔºày ËΩ¥ log scaleÔºâÂíåÁ¥ØËÆ° LLM Ë¥πÁî®ÔºàÂè≥ y ËΩ¥ÔºâÁöÑÂØπÊØîÊõ≤Á∫ø„ÄÇ
     Argus Âú®Âá†ÂàÜÈíüÂÜÖÂÆåÊàê Phase I ÂêéÔºåPhase II ÁöÑ throughput ËøúÈ´ò‰∫é baseline„ÄÇ
-->

Argus's two-stage design is *dramatically* more efficient than a naive LLM baseline that generates full concrete query pairs directly:

<table class="table table-sm" style="width: auto; margin: 1rem auto 2rem; font-family: 'Open Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; font-size: 0.88rem; border: 1px solid #ccc; color: var(--global-text-color);">
  <thead style="background-color: #f0f0f0; font-weight: 600;">
    <tr>
      <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px; color: var(--global-text-color);">Cost Item</th>
      <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px; color: var(--global-text-color);">Argus</th>
    </tr>
  </thead>
  <tbody>
    <tr><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">CAQ pair generation (Phase I)</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">~$3</td></tr>
    <tr><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">Snippet corpus (100,000 snippets)</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">~$12</td></tr>
    <tr><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">Instantiation</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">~$1 / 1,000 test cases</td></tr>
  </tbody>
</table>

The naive baseline generates test cases orders of magnitude more slowly because it must call the LLM for every single test case.

#### Soundness: Why the SQL Prover Matters

<!-- üì∏ IMAGE PLACEHOLDER 9
     Âª∫ËÆÆ: ÊèíÂÖ•‰∏ÄÂº†ÂØπÊØîÂõæÊàñË°®Ê†ºÔºåÂ±ïÁ§∫ LLM-as-a-judge vs SQL equivalence prover ÁöÑÊïàÊûúÂØπÊØîÔºå
     Ê†∏ÂøÉÊï∞ÊçÆ: LLM-as-a-judge ‰∫ßÁîüÁöÑ 20 ‰∏™ bug report ÂÖ®ÈÉ®ÊòØ false positiveÔºà0 ‰∏™Áúü bugÔºâÔºå
     ËÄå prover È™åËØÅÁöÑ oracle ‰∫ßÁîüÁöÑ bug report ÂÖ®ÈÉ®ÊòØÁúü bugÔºà0 false positiveÔºâ„ÄÇ
     ÂèØ‰ª•ÊòØÂπªÁÅØÁâá‰∏≠ÂØπÂ∫îÁöÑÂØπÊØî slide Êà™Âõæ„ÄÇ
-->

When we replaced the SQL equivalence prover with **LLM-as-a-judge** (using `GPT-4`):
- 20 consecutive bug reports were **all false positives**
- Among 20 LLM-judged-equivalent CAQ pairs, 1 was actually inequivalent (5% error rate)

In mature DBMSs, finding a single real bug may require *thousands* of queries. Even a 5% error rate overwhelmingly drowns out true bugs. The prover is not optional ‚Äî it's what makes Argus *practical*.

---

### What Makes Argus Different

<table class="table table-sm" style="width: auto; margin: 1rem auto 2rem; font-family: 'Open Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; font-size: 0.88rem; border: 1px solid #ccc; color: var(--global-text-color);">
  <thead style="background-color: #f0f0f0; font-weight: 600;">
    <tr>
      <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px; color: var(--global-text-color);">Aspect</th>
      <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px; color: var(--global-text-color);">Prior work</th>
      <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px; color: var(--global-text-color);">Argus</th>
    </tr>
  </thead>
  <tbody>
    <tr><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">Oracle design</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">Manual, expert-crafted</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">Automated by LLM</td></tr>
    <tr><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">Soundness</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">Assumed correct</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">Formally verified by SQL prover</td></tr>
    <tr><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">Scalability</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">~10s of hand-written oracles</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">Thousands of verified CAQ pairs</td></tr>
  </tbody>
</table>

---

### Discussion

**Prover limitations are opportunities.** SQL equivalence provers currently support a subset of SQL features (core Calcite syntax: outer joins, nested queries, basic aggregations). Argus's two-stage design mitigates this by *proving equivalence at the abstract CAQ level*, then instantiating placeholders with complex, DBMS-specific snippets that go beyond the prover's reasoning capabilities.

**We also found prover bugs.** During development, Argus revealed **10 bugs in `SQLSolver` and `QED`** ‚Äî incorrect equivalence proofs that would have caused false positives. All were fixed quickly. Improving Argus simultaneously improves the tools it depends on.

**Extensible by design.** Argus can be steered toward specific SQL features simply by adjusting the LLM prompt (e.g., "ensure the generated snippet includes at least one `OUTER JOIN`"). No code changes needed.

**Future directions.** Two natural extensions:
1. **Expand the target domain.** Argus's core idea ‚Äî using LLMs to discover semantic equivalences and formally verifying them ‚Äî is not specific to relational DBMSs. The same paradigm could apply to **compilers** (e.g., finding equivalent IR transformations that expose miscompilation bugs), **network systems** (e.g., equivalent packet-forwarding rules that reveal routing inconsistencies), or **graph/spatial databases** (e.g., equivalent graph traversal queries). Any domain with a formal notion of equivalence and a verifier is a candidate.
2. **Oracle prioritization.** Given thousands of LLM-generated oracles, which are most likely to find bugs in a specific DBMS? Combining coverage feedback, historical bug patterns, and oracle structural diversity could guide Argus toward higher-yield test oracles.

---

### Citation

```bibtex
@misc{mang2025argus,
  title         = {Automated Discovery of Test Oracles for Database Management Systems Using LLMs},
  author        = {Qiuyang Mang and Runyuan He and Suyang Zhong and Xiaoxuan Liu and Huanchen Zhang and Alvin Cheung},
  year          = {2025},
  eprint        = {2510.06663},
  archivePrefix = {arXiv},
  primaryClass  = {cs.DB},
  url           = {https://arxiv.org/abs/2510.06663}
}
```

---

*This work was accepted at [SIGMOD 2026](https://2026.sigmod.org/). Find out more: [[arXiv]](https://arxiv.org/abs/2510.06663) [[Slides]](/assets/pdf/argus.pdf)*
