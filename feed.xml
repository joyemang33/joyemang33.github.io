<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://joyemang33.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://joyemang33.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2026-02-23T23:56:07+00:00</updated><id>https://joyemang33.github.io/feed.xml</id><title type="html">blank</title><subtitle>A undergraduate student in Testing, Database, Graph. </subtitle><entry><title type="html">Argus: Automated Discovery of Test Oracles for Database Management Systems Using LLMs</title><link href="https://joyemang33.github.io/blog/2026/argus/" rel="alternate" type="text/html" title="Argus: Automated Discovery of Test Oracles for Database Management Systems Using LLMs"/><published>2026-02-23T00:00:00+00:00</published><updated>2026-02-23T00:00:00+00:00</updated><id>https://joyemang33.github.io/blog/2026/argus</id><content type="html" xml:base="https://joyemang33.github.io/blog/2026/argus/"><![CDATA[<hr/> <h3 id="tldr">TL;DR</h3> <p>Database Management Systems (DBMSs) are notoriously hard to test because you need a <em>test oracle</em> ‚Äî a way to know if the output is correct. Prior work builds these oracles <strong>by hand</strong>, creating a never-ending cycle of manual effort.</p> <p><strong>Argus</strong> breaks this cycle by using LLMs to <em>automatically discover</em> test oracles, then formally <em>verifies</em> them with a SQL equivalence prover for soundness, and efficiently <em>instantiates</em> them into thousands of concrete test cases. Evaluated on five heavily-tested DBMSs, Argus found <strong>41 previously unknown bugs</strong> (36 logic bugs), outperforming state-of-the-art manual oracle designs.</p> <p>In practice, spending just <strong>~$10</strong> on LLM calls generates <strong>millions of reliable SQL tests</strong> ‚Äî each capable of catching <em>logic bugs</em>, where a query silently returns wrong results instead of throwing an error.</p> <hr/> <h3 id="the-problem-test-oracles-are-a-bottleneck">The Problem: Test Oracles Are a Bottleneck</h3> <p><img src="https://joyemang33.github.io/assets/img/argus-1.png" alt="Test Oracle Problem" style="max-width: 75%; display: block; margin: 1rem auto;"/></p> <p>When testing a DBMS, how do you know if the result of a SQL query is <em>correct</em>? This is the <strong>test oracle problem</strong>. A naive approach would be to compare two DBMSs against each other, but that misses bugs they share. The dominant approach instead builds <em>semantic equivalence oracles</em>: transform a query \(Q\) into a semantically equivalent \(Q'\), run both, and flag inconsistencies as bugs.</p> <p>The catch: <strong>designing such transformation mechanisms is entirely manual</strong>. Researchers have published over 20 top-conference papers, each hand-crafting specialized oracles ‚Äî <a href="https://dl.acm.org/doi/10.1145/3428279"><code class="language-plaintext highlighter-rouge">TLP</code></a>, <a href="https://dl.acm.org/doi/10.1145/3368089.3409710"><code class="language-plaintext highlighter-rouge">NoREC</code></a>, <a href="https://github.com/JZuming/EET"><code class="language-plaintext highlighter-rouge">EET</code></a>, <a href="https://dl.acm.org/doi/10.1145/3654990"><code class="language-plaintext highlighter-rouge">DQP</code></a> ‚Äî yet bugs keep slipping through. Consider this real TiDB bug that went undetected for <em>years</em>:</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">t1</span><span class="p">(</span><span class="k">c</span> <span class="nb">INT</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">t1</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">-- Q: Empty table filter ‚Üí should return {}</span>
<span class="k">SELECT</span> <span class="k">c</span> <span class="o">/</span> <span class="mi">3</span> <span class="k">FROM</span> <span class="n">t1</span> <span class="k">WHERE</span> <span class="k">false</span><span class="p">;</span>       <span class="c1">-- {} ‚úì</span>

<span class="c1">-- Oracle: Q EXCEPT Q should always be empty</span>
<span class="k">SELECT</span> <span class="k">c</span> <span class="o">/</span> <span class="mi">3</span> <span class="k">FROM</span> <span class="n">t1</span> <span class="k">EXCEPT</span> <span class="k">SELECT</span> <span class="k">c</span> <span class="o">/</span> <span class="mi">3</span> <span class="k">FROM</span> <span class="n">t1</span><span class="p">;</span>  <span class="c1">-- {0.3333} ‚úó (BUG!)</span>
</code></pre></div></div> <p>Catching this required the very specific insight that \(Q \setminus Q = \emptyset\). A human had to think of it. Can we make a machine do that automatically?</p> <hr/> <h3 id="key-insight-constrained-abstract-queries-caq">Key Insight: Constrained Abstract Queries (CAQ)</h3> <p>The core innovation in Argus is a new representation called a <strong>Constrained Abstract Query (CAQ)</strong> ‚Äî a SQL query template with typed <em>placeholders</em> that can be filled with concrete SQL snippets.</p> <p>A placeholder \(\square_i\) can be either:</p> <ul> <li><strong><code class="language-plaintext highlighter-rouge">Expr(TableName : SQLDatatype)</code></strong> ‚Äî any expression over a table that returns a given type (e.g., a Boolean expression over <code class="language-plaintext highlighter-rouge">t1</code>)</li> <li><strong><code class="language-plaintext highlighter-rouge">Table(SQLTableDef)</code></strong> ‚Äî any table or subquery with a given schema</li> </ul> <p>An <strong>equivalent CAQ pair</strong> \((s, q_1, q_2)\) is two CAQs that produce the <em>same results for every possible instantiation</em> of their placeholders. For example, the classic <strong>TLP oracle</strong> can be expressed as a CAQ pair:</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- Q‚ÇÅ: seed query</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">t1</span><span class="p">,</span> <span class="err">‚ñ°‚ÇÅ‚ä≤</span><span class="k">Table</span><span class="p">(...);</span>

<span class="c1">-- Q‚ÇÇ: TLP three-way partition</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">t1</span><span class="p">,</span> <span class="err">‚ñ°‚ÇÅ‚ä≤</span><span class="k">Table</span><span class="p">(...)</span> <span class="k">WHERE</span> <span class="p">(</span><span class="err">‚ñ°‚ÇÇ‚ä≤</span><span class="n">Expr</span><span class="p">(</span><span class="n">t1</span><span class="p">:</span><span class="nb">BOOLEAN</span><span class="p">)</span> <span class="k">IS</span> <span class="k">TRUE</span><span class="p">)</span>
<span class="k">UNION</span> <span class="k">ALL</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">t1</span><span class="p">,</span> <span class="err">‚ñ°‚ÇÅ‚ä≤</span><span class="k">Table</span><span class="p">(...)</span> <span class="k">WHERE</span> <span class="p">(</span><span class="err">‚ñ°‚ÇÇ‚ä≤</span><span class="n">Expr</span><span class="p">(</span><span class="n">t1</span><span class="p">:</span><span class="nb">BOOLEAN</span><span class="p">)</span> <span class="k">IS</span> <span class="k">FALSE</span><span class="p">)</span>
<span class="k">UNION</span> <span class="k">ALL</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">t1</span><span class="p">,</span> <span class="err">‚ñ°‚ÇÅ‚ä≤</span><span class="k">Table</span><span class="p">(...)</span> <span class="k">WHERE</span> <span class="p">(</span><span class="err">‚ñ°‚ÇÇ‚ä≤</span><span class="n">Expr</span><span class="p">(</span><span class="n">t1</span><span class="p">:</span><span class="nb">BOOLEAN</span><span class="p">)</span> <span class="k">IS</span> <span class="k">NULL</span><span class="p">);</span>

<span class="c1">-- Instantiation examples:</span>
<span class="c1">-- ‚ñ°‚ÇÅ ‚Ü¶ t1 ASOF JOIN t2</span>
<span class="c1">-- ‚ñ°‚ÇÇ ‚Ü¶ json_valid(t1.c0)</span>
</code></pre></div></div> <p>The power of CAQs: one CAQ pair is a reusable oracle that can generate <em>thousands</em> of concrete test cases by filling its placeholders with diverse SQL snippets.</p> <hr/> <h3 id="the-argus-pipeline">The Argus Pipeline</h3> <p><img src="https://joyemang33.github.io/assets/img/argus-2.png" alt="Overall pipeline of Argus" style="max-width: 90%; display: block; margin: 1rem auto;"/></p> <p>Argus operates in two stages:</p> <h4 id="stage-1--test-oracle-discovery-offline-one-time">Stage 1 ‚Äî Test Oracle Discovery (offline, one-time)</h4> <p><strong>‚ë† Database Seeding.</strong> A grammar-based generator (<a href="https://github.com/sqlancer/sqlancer"><code class="language-plaintext highlighter-rouge">SQLancer</code></a>) produces random database schemas and seed CAQs. Virtual columns and tables serve as placeholders, making the output compatible with SQL provers that expect concrete syntax.</p> <p><strong>‚ë° LLM-based Oracle Generation + Formal Verification.</strong> For each seed CAQ \(q\), Argus iteratively prompts an LLM to generate an equivalent variant \(q'\). Two mechanisms ensure quality:</p> <ul> <li><strong>In-context learning</strong> ‚Äî the LLM is shown verified successes (<em>Equal</em> set) and failures (<em>Fail</em> set) from previous rounds.</li> <li><strong>Diversity-oriented sampling</strong> ‚Äî verified CAQs are clustered by query-plan tree-edit distance (k-means), and samples are drawn from each cluster to push the LLM toward novel execution plans.</li> </ul> <p>Every candidate \(q'\) must pass a <strong>SQL equivalence prover</strong> (<a href="https://github.com/SJTU-IPADS/SQLSolver"><code class="language-plaintext highlighter-rouge">SQLSolver</code></a>) before acceptance. Placeholders are replaced by virtual entities so the prover can reason on concrete queries. Only formally verified pairs become test oracles ‚Äî <strong>zero false positives by design</strong>.</p> <h4 id="stage-2--test-case-instantiation-online-per-dbms">Stage 2 ‚Äî Test Case Instantiation (online, per DBMS)</h4> <p><strong>‚ë¢ Corpus Synthesis.</strong> A hybrid approach (LLM + grammar-based generator) pre-generates a large library of SQL snippets:</p> <ul> <li>LLMs produce <em>complex, feature-rich</em> expressions and table structures, guided by official DBMS documentation.</li> <li>The grammar-based generator covers <em>corner values and edge cases</em> systematically.</li> <li><strong>Cross-combination</strong>: expressions are recursively composed (e.g., substituting a <code class="language-plaintext highlighter-rouge">Boolean</code> expr into an <code class="language-plaintext highlighter-rouge">INT</code> function that expects a Boolean column) to create intricate multi-level expressions.</li> <li>Every snippet is <em>runtime-validated</em> on the target DBMS to filter type mismatches and invalid SQL.</li> </ul> <p><strong>‚ë£‚ë§‚ë• Instantiation &amp; Bug Detection.</strong> Each verified CAQ pair is instantiated up to \(K\) times by randomly sampling compatible snippets from the corpus. Placeholders are replaced consistently in both \(q\) and \(q'\). Random database instances are created, and the two queries are executed. Any result mismatch is a bug report.</p> <p>Three <em>general constraints</em> on snippets guarantee that instantiated pairs remain equivalent even when concrete expressions are plugged in:</p> <ol> <li><strong>Determinism</strong> ‚Äî no <code class="language-plaintext highlighter-rouge">RANDOM()</code>, <code class="language-plaintext highlighter-rouge">CURRENT_TIMESTAMP</code>, etc.</li> <li><strong>Null-preserving</strong> ‚Äî expression returns <code class="language-plaintext highlighter-rouge">NULL</code> when evaluated on all-<code class="language-plaintext highlighter-rouge">NULL</code> rows.</li> <li><strong>Empty-result-preserving</strong> ‚Äî expression returns empty on an empty table.</li> </ol> <hr/> <h3 id="representative-bugs-found">Representative Bugs Found</h3> <p style="font-size: 1rem; font-weight: 700; margin-bottom: 0.3rem;">üìå PostgreSQL: Incorrect json function in RIGHT JOIN</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">t</span><span class="p">(</span><span class="k">c</span> <span class="nb">INT</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">t</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">-- Q1: RIGHT JOIN with FALSE ‚Üí left side always NULL</span>
<span class="k">SELECT</span> <span class="n">sub</span><span class="p">.</span><span class="k">c</span> <span class="k">FROM</span> <span class="p">(</span>
  <span class="k">SELECT</span> <span class="n">json_array_length</span><span class="p">(</span><span class="n">json_array</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">.</span><span class="k">c</span><span class="p">))</span> <span class="k">AS</span> <span class="k">c</span> <span class="k">FROM</span> <span class="n">t</span>
<span class="p">)</span> <span class="k">AS</span> <span class="n">sub</span> <span class="k">RIGHT</span> <span class="k">JOIN</span> <span class="n">t</span> <span class="k">ON</span> <span class="k">FALSE</span><span class="p">;</span>  <span class="c1">-- Expected: {NULL}, Got: {2} ‚úó</span>

<span class="c1">-- Q2: explicitly NULL in subquery</span>
<span class="k">SELECT</span> <span class="n">sub</span><span class="p">.</span><span class="k">c</span> <span class="k">FROM</span> <span class="p">(</span><span class="k">SELECT</span> <span class="k">NULL</span> <span class="k">AS</span> <span class="k">c</span> <span class="k">FROM</span> <span class="n">t</span><span class="p">)</span> <span class="k">AS</span> <span class="n">sub</span>
<span class="k">RIGHT</span> <span class="k">JOIN</span> <span class="n">t</span> <span class="k">ON</span> <span class="k">FALSE</span><span class="p">;</span>  <span class="c1">-- {NULL} ‚úì</span>
</code></pre></div></div> <p><strong>Root cause:</strong> PostgreSQL‚Äôs json functions bypass the null-propagation rule for <code class="language-plaintext highlighter-rouge">RIGHT JOIN</code>, producing incorrect non-null values. Reported and fixed within <strong>24 hours</strong>.</p> <p style="font-size: 1rem; font-weight: 700; margin-bottom: 0.3rem;">üìå Dolt: EXISTS duplicates rows</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">t</span><span class="p">(</span><span class="n">c0</span> <span class="nb">INT</span><span class="p">,</span> <span class="n">c1</span> <span class="nb">INT</span><span class="p">,</span> <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">c0</span><span class="p">,</span> <span class="n">c1</span><span class="p">));</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">t</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>

<span class="c1">-- With NOT NULL primary key, EXISTS is always TRUE ‚Üí should return all rows once</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">t</span> <span class="k">WHERE</span> <span class="k">EXISTS</span> <span class="p">(</span><span class="k">SELECT</span> <span class="mi">1</span> <span class="k">FROM</span> <span class="n">t</span> <span class="k">AS</span> <span class="n">x</span> <span class="k">WHERE</span> <span class="n">x</span><span class="p">.</span><span class="n">c0</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">c0</span><span class="p">);</span>
<span class="c1">-- Got: {(1,1),(2,2),(2,3),(1,1),(2,2),(2,3)} ‚úó ‚Äî every row duplicated!</span>

<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">t</span><span class="p">;</span>  <span class="c1">-- {(1,1),(2,2),(2,3)} ‚úì</span>
</code></pre></div></div> <p style="font-size: 1rem; font-weight: 700; margin-bottom: 0.3rem;">üìå DuckDB: Empty CTE incorrectly short-circuits UNION ALL</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">t1</span><span class="p">(</span><span class="n">c0</span> <span class="nb">BOOLEAN</span><span class="p">);</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">t2</span><span class="p">(</span><span class="n">c0</span> <span class="nb">BOOLEAN</span><span class="p">);</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">t3</span><span class="p">(</span><span class="n">c0</span> <span class="nb">BOOLEAN</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">t2</span> <span class="k">VALUES</span> <span class="p">(</span><span class="k">true</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">t3</span> <span class="k">VALUES</span> <span class="p">(</span><span class="k">true</span><span class="p">);</span>

<span class="c1">-- Q1</span>
<span class="k">SELECT</span> <span class="n">t2</span><span class="p">.</span><span class="n">c0</span> <span class="k">FROM</span> <span class="n">t2</span><span class="p">,</span> <span class="n">t3</span> <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">t1</span> <span class="k">ON</span> <span class="k">false</span><span class="p">;</span>  <span class="c1">-- {true} ‚úì</span>

<span class="c1">-- Q2 (equivalent via CTE expansion)</span>
<span class="k">WITH</span> <span class="k">c</span> <span class="k">AS</span> <span class="p">(</span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">t1</span> <span class="k">WHERE</span> <span class="k">false</span><span class="p">)</span>
<span class="k">SELECT</span> <span class="n">t2</span><span class="p">.</span><span class="n">c0</span> <span class="k">FROM</span> <span class="n">t2</span> <span class="k">CROSS</span> <span class="k">JOIN</span> <span class="n">t3</span> <span class="k">CROSS</span> <span class="k">JOIN</span> <span class="k">c</span>
<span class="k">UNION</span> <span class="k">ALL</span>
<span class="k">SELECT</span> <span class="n">t2</span><span class="p">.</span><span class="n">c0</span> <span class="k">FROM</span> <span class="n">t2</span> <span class="k">CROSS</span> <span class="k">JOIN</span> <span class="n">t3</span> <span class="k">WHERE</span> <span class="k">NOT</span> <span class="k">EXISTS</span> <span class="p">(</span><span class="k">SELECT</span> <span class="mi">1</span> <span class="k">FROM</span> <span class="k">c</span><span class="p">);</span>
<span class="c1">-- Got: {0 rows} ‚úó</span>
</code></pre></div></div> <p><strong>Root cause:</strong> DuckDB incorrectly assumes an empty materialized CTE always causes the outer query to return no rows ‚Äî not true with <code class="language-plaintext highlighter-rouge">UNION ALL</code>.</p> <p style="font-size: 0.85rem; background: var(--global-code-bg-color, #f6f8fa); border-left: 3px solid #6c8ebf; padding: 0.6rem 0.9rem; border-radius: 4px; margin: 1rem 0;">üéâ <strong>Real-world impact:</strong> Dolt <a href="https://www.dolthub.com/blog/2025-10-21-ai-sql-testing/">officially wrote about Argus on their blog</a>, detailing how our AI-generated SQL tests found <strong>19 bugs</strong> in their database engine and how they are integrating the Argus-generated test suite into their regression testing process.</p> <hr/> <h3 id="evaluation-results">Evaluation Results</h3> <h4 id="bugs-found-5-dbmss-2-month-campaign">Bugs Found (5 DBMSs, 2-month campaign)</h4> <table class="table table-sm text-center" style="width: auto; margin: 1rem auto 2rem; font-family: 'Open Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; font-size: 0.88rem; border: 1px solid #ccc; color: var(--global-text-color);"> <thead style="background-color: #f0f0f0; font-weight: 600;"> <tr> <th class="text-start" style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px; color: var(--global-text-color);">DBMS</th> <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px; color: var(--global-text-color);">Reported</th> <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px; color: var(--global-text-color);">Fixed</th> <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px; color: var(--global-text-color);">Confirmed</th> <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px; color: var(--global-text-color);">Logic Bugs</th> </tr> </thead> <tbody> <tr><td class="text-start" style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">Dolt</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">19</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">18</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">19</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">18</td></tr> <tr><td class="text-start" style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">DuckDB</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">8</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">6</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">7</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">4</td></tr> <tr><td class="text-start" style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">MySQL</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">8</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">0</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">5</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">8</td></tr> <tr><td class="text-start" style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">PostgreSQL</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">1</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">1</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">1</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">1</td></tr> <tr><td class="text-start" style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">TiDB</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">5</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">2</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">5</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">5</td></tr> <tr style="font-weight: 700; border-top: 2px solid #ccc;"><td class="text-start" style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">Total</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">41</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">27</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">36</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">36</td></tr> </tbody> </table> <p>36 out of 41 bugs are <strong>logic bugs</strong> ‚Äî the silent, most dangerous class that cause incorrect query results without any error. Compared to recent works with manually crafted oracles, Argus finds <em>more</em> despite targeting DBMSs already extensively tested.</p> <h4 id="code-coverage">Code Coverage</h4> <p>On <strong>DuckDB</strong> (24-hour run):</p> <ul> <li>Argus achieves <strong>+19.9% line coverage</strong> and <strong>+18.1% branch coverage</strong> over <code class="language-plaintext highlighter-rouge">SQLancer++</code></li> <li><strong>5.5√ó line</strong> and <strong>6.4√ó function</strong> <a href="https://arxiv.org/abs/2508.16307">metamorphic coverage</a> over <code class="language-plaintext highlighter-rouge">SQLancer</code> ‚Äî <em>metamorphic coverage</em> measures how much code is exercised <em>differently</em> between the two equivalent queries, directly correlating with logic bug-finding ability</li> </ul> <p>On <strong>PostgreSQL</strong>:</p> <ul> <li>Outperforms <code class="language-plaintext highlighter-rouge">SQLancer++</code> by <strong>+19.0% line</strong> and <strong>+22.5% branch</strong> coverage</li> <li>Covers <strong>23 query features</strong> (vs <code class="language-plaintext highlighter-rouge">SQLancer</code>‚Äôs 15 in <code class="language-plaintext highlighter-rouge">pglast</code>), demonstrating the LLM‚Äôs ability to generate feature-rich queries</li> </ul> <h4 id="new-oracles-vs-prior-manual-oracles">New Oracles vs. Prior Manual Oracles</h4> <p>In a head-to-head comparison on Dolt v1.0.0 (6-hour window), using <strong>the same snippet corpus and CAQ format</strong> for fairness:</p> <ul> <li><strong>Argus-5,000 oracles</strong>: found <strong>10 unique logic bugs</strong></li> <li><strong>Baseline</strong> (union of <a href="https://dl.acm.org/doi/10.1145/3428279"><code class="language-plaintext highlighter-rouge">TLP</code></a> + <a href="https://dl.acm.org/doi/10.1145/3368089.3409710"><code class="language-plaintext highlighter-rouge">NoREC</code></a> + <a href="https://www.usenix.org/conference/osdi24/presentation/jiang-zu-ming"><code class="language-plaintext highlighter-rouge">EET</code></a> + <a href="https://dl.acm.org/doi/10.1145/3654991"><code class="language-plaintext highlighter-rouge">DQP</code></a> ‚Äî 11 hand-crafted oracles): found <strong>3</strong></li> <li>Argus-50 oracles (fewer than baseline): found only 2, confirming the <em>quantity</em> of oracles matters</li> </ul> <p>The <strong>3.33√ó improvement</strong> demonstrates that automation unlocks oracle diversity that manual design simply cannot match at scale.</p> <h4 id="cost--efficiency">Cost &amp; Efficiency</h4> <p><img src="https://joyemang33.github.io/assets/img/argus-3.png" alt="Argus-cost" style="max-width:60%; display: block; margin: 1rem auto;"/></p> <p>Argus‚Äôs two-stage design is <em>dramatically</em> more efficient than a naive LLM baseline that generates full concrete query pairs directly:</p> <table class="table table-sm" style="width: auto; margin: 1rem auto 2rem; font-family: 'Open Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; font-size: 0.88rem; border: 1px solid #ccc; color: var(--global-text-color);"> <thead style="background-color: #f0f0f0; font-weight: 600;"> <tr> <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px; color: var(--global-text-color);">Cost Item</th> <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px; color: var(--global-text-color);">Phase</th> <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px; text-align: center; color: var(--global-text-color);">Cost</th> </tr> </thead> <tbody> <tr> <td style="border-color: #ccc; padding: 4px 10px; color: var(--global-text-color);">CAQ pair generation</td> <td style="border-color: #ccc; padding: 4px 10px; color: var(--global-text-color); font-size: 0.82rem;">Offline ¬∑ one-time</td> <td style="border-color: #ccc; padding: 4px 10px; text-align: center; font-weight: 600; color: var(--global-text-color);">~$3</td> </tr> <tr> <td style="border-color: #ccc; padding: 4px 10px; color: var(--global-text-color);">Snippet corpus <span style="font-size: 0.82rem; color: #888;">(100,000 snippets)</span></td> <td style="border-color: #ccc; padding: 4px 10px; color: var(--global-text-color); font-size: 0.82rem;">Offline ¬∑ per DBMS</td> <td style="border-color: #ccc; padding: 4px 10px; text-align: center; font-weight: 600; color: var(--global-text-color);">~$12</td> </tr> <tr> <td style="border-color: #ccc; padding: 4px 10px; color: var(--global-text-color);">Instantiation &amp; test execution</td> <td style="border-color: #ccc; padding: 4px 10px; color: var(--global-text-color); font-size: 0.82rem;">Online ¬∑ reusable</td> <td style="border-color: #ccc; padding: 4px 10px; text-align: center; font-weight: 600; color: var(--global-text-color);">FREE</td> </tr> </tbody> </table> <p>The naive baseline generates test cases orders of magnitude more slowly because it must call the LLM for every single test case.</p> <h4 id="soundness-why-the-sql-prover-matters">Soundness: Why the SQL Prover Matters</h4> <p>When we replaced the SQL equivalence prover with <strong>LLM-as-a-judge</strong> (using <code class="language-plaintext highlighter-rouge">GPT-5</code>):</p> <ul> <li>20 consecutive bug reports were <strong>all false positives</strong></li> <li>Among 20 LLM-judged-equivalent CAQ pairs, 1 was actually inequivalent (5% error rate)</li> </ul> <p>In mature DBMSs, finding a single real bug may require <em>thousands</em> of queries. Even a 5% error rate overwhelmingly drowns out true bugs. The prover is not optional ‚Äî it‚Äôs what makes Argus <em>practical</em>.</p> <hr/> <h3 id="what-makes-argus-different">What Makes Argus Different</h3> <table class="table table-sm" style="width: auto; margin: 1rem auto 2rem; font-family: 'Open Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; font-size: 0.88rem; border: 1px solid #ccc; color: var(--global-text-color);"> <thead style="background-color: #f0f0f0; font-weight: 600;"> <tr> <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px; color: var(--global-text-color);">Aspect</th> <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px; color: var(--global-text-color);">Prior work</th> <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px; color: var(--global-text-color);">Argus</th> </tr> </thead> <tbody> <tr><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">Oracle design</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">Manual, expert-crafted</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">Automated by LLM</td></tr> <tr><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">Soundness</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">Assumed correct</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">Formally verified by SQL prover</td></tr> <tr><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">Scalability</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">~10s of hand-written oracles</td><td style="border-color: #ccc; padding: 3px 10px; color: var(--global-text-color);">Thousands of verified CAQ pairs</td></tr> </tbody> </table> <hr/> <h3 id="discussion">Discussion</h3> <p><strong>Prover limitations are opportunities.</strong> SQL equivalence provers currently support a subset of SQL features (core Calcite syntax: outer joins, nested queries, basic aggregations). Argus‚Äôs two-stage design mitigates this by <em>proving equivalence at the abstract CAQ level</em>, then instantiating placeholders with complex, DBMS-specific snippets that go beyond the prover‚Äôs reasoning capabilities.</p> <p><strong>We also found prover bugs.</strong> During development, Argus revealed <strong>10 bugs in <a href="https://github.com/SJTU-IPADS/SQLSolver"><code class="language-plaintext highlighter-rouge">SQLSolver</code></a> and <a href="https://github.com/qed-solver"><code class="language-plaintext highlighter-rouge">QED</code></a></strong> ‚Äî incorrect equivalence proofs that would have caused false positives. All were fixed quickly. Improving Argus simultaneously improves the tools it depends on.</p> <p><strong>Extensible by design.</strong> Argus can be steered toward specific SQL features simply by adjusting the LLM prompt (e.g., ‚Äúensure the generated snippet includes at least one <code class="language-plaintext highlighter-rouge">OUTER JOIN</code>‚Äù). No code changes needed.</p> <p><strong>Future directions.</strong> Two natural extensions:</p> <ol> <li><strong>Expand the target domain.</strong> Argus‚Äôs core idea ‚Äî using LLMs to discover semantic equivalences and formally verifying them ‚Äî is not specific to relational DBMSs. The same paradigm could apply to <strong>compilers</strong> (e.g., finding equivalent IR transformations that expose miscompilation bugs), <strong>network systems</strong> (e.g., equivalent packet-forwarding rules that reveal routing inconsistencies), or <strong>graph/spatial databases</strong> (e.g., equivalent graph traversal queries). Any domain with a formal notion of equivalence and a verifier is a candidate.</li> <li><strong>Oracle prioritization.</strong> Given thousands of LLM-generated oracles, which are most likely to find bugs in a specific DBMS? Combining coverage feedback, historical bug patterns, and oracle structural diversity could guide Argus toward higher-yield test oracles.</li> </ol> <hr/> <h3 id="citation">Citation</h3> <div class="language-bibtex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">@misc</span><span class="p">{</span><span class="nl">mang2025argus</span><span class="p">,</span>
  <span class="na">title</span>         <span class="p">=</span> <span class="s">{Automated Discovery of Test Oracles for Database Management Systems Using LLMs}</span><span class="p">,</span>
  <span class="na">author</span>        <span class="p">=</span> <span class="s">{Qiuyang Mang and Runyuan He and Suyang Zhong and Xiaoxuan Liu and Huanchen Zhang and Alvin Cheung}</span><span class="p">,</span>
  <span class="na">year</span>          <span class="p">=</span> <span class="s">{2025}</span><span class="p">,</span>
  <span class="na">eprint</span>        <span class="p">=</span> <span class="s">{2510.06663}</span><span class="p">,</span>
  <span class="na">archivePrefix</span> <span class="p">=</span> <span class="s">{arXiv}</span><span class="p">,</span>
  <span class="na">primaryClass</span>  <span class="p">=</span> <span class="s">{cs.DB}</span><span class="p">,</span>
  <span class="na">url</span>           <span class="p">=</span> <span class="s">{https://arxiv.org/abs/2510.06663}</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><em>This work was accepted at <a href="https://2026.sigmod.org/">SIGMOD 2026</a>. Find out more: <a href="https://arxiv.org/abs/2510.06663">[arXiv]</a> <a href="/assets/pdf/argus.pdf">[Slides]</a> <a href="https://www.dolthub.com/blog/2025-10-21-ai-sql-testing/">[Dolt Blog]</a></em></p>]]></content><author><name>Qiuyang Mang, Runyuan He, Suyang Zhong, Xiaoxuan Liu, Huanchen Zhang, Alvin Cheung</name></author><category term="research"/><category term="database"/><category term="testing"/><category term="LLM"/><category term="SQL"/><category term="Auto Discovery"/><summary type="html"><![CDATA[We present Argus, a novel framework that uses LLMs to automatically discover test oracles for DBMS testing ‚Äî finding 41 previously unknown bugs across 5 widely-used databases. Accepted at SIGMOD 2026.]]></summary></entry></feed>