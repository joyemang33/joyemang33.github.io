---
layout: post
title: "Argus: Automated Discovery of Test Oracles for Database Management Systems Using LLMs"
date: 2026-02-23
author: "Qiuyang Mang, Runyuan He, Suyang Zhong, Xiaoxuan Liu, Huanchen Zhang, Alvin Cheung"
description: We present Argus, a novel framework that uses LLMs to automatically discover test oracles for DBMS testing ‚Äî finding 41 previously unknown bugs across 5 widely-used databases. Accepted at SIGMOD 2026.
tags: [database, testing, LLM, DBMS, SQL]
categories: research
related_posts: false
toc:
  sidebar: left
---

This work was accepted at [SIGMOD 2026](https://2026.sigmod.org/). [[arXiv]](https://arxiv.org/abs/2510.06663) [[Slides]](/assets/pdf/argus.pdf)

---

### TL;DR

Database Management Systems (DBMSs) are notoriously hard to test because you need a *test oracle* ‚Äî a way to know if the output is correct. Prior work builds these oracles **by hand**, creating a never-ending cycle of manual effort.

**Argus** breaks this cycle by using LLMs to *automatically discover* test oracles, then formally *verifies* them with a SQL equivalence prover for soundness, and efficiently *instantiates* them into thousands of concrete test cases. Evaluated on five heavily-tested DBMSs, Argus found **41 previously unknown bugs** (36 logic bugs), outperforming state-of-the-art manual oracle designs.

---

### The Problem: Test Oracles Are a Bottleneck

<!-- üì∏ IMAGE PLACEHOLDER 1
     Âª∫ËÆÆ: ÊèíÂÖ•‰∏ÄÂº†"Test Oracle Problem"ÁöÑÁ§∫ÊÑèÂõæÔºå
     ÊòæÁ§∫: ÁªôÂÆö‰∏ÄÊù° SQL Êü•ËØ¢ÔºåDBMS ËøîÂõûÁªìÊûúÔºå‰ΩÜÊàë‰ª¨ÊÄé‰πàÁü•ÈÅìÁªìÊûúÊòØÂê¶Ê≠£Á°ÆÔºü
     ÂèØ‰ª•ÊòØÂπªÁÅØÁâá‰∏≠ÂÖ≥‰∫é"motivating example"ÈÇ£‰∏ÄÈ°µÁöÑÊà™ÂõæÔºå
     Êàñ‰∏Ä‰∏™ÁÆÄÊ¥ÅÁöÑ diagramÔºåÂ∑¶ËæπÊòØ SQL queryÔºåÂè≥ËæπÊòØ DBMS outputÔºå
     ‰∏≠Èó¥Áî®ÈóÆÂè∑Ë°®Á§∫"test oracle"Âà§Êñ≠Ê≠£Á°ÆÊÄßÁöÑËøáÁ®ã„ÄÇ
-->

When testing a DBMS, how do you know if the result of a SQL query is *correct*? This is the **test oracle problem**. A naive approach would be to compare two DBMSs against each other, but that misses bugs they share. The dominant approach instead builds *semantic equivalence oracles*: transform a query $$Q$$ into a semantically equivalent $$Q'$$, run both, and flag inconsistencies as bugs.

The catch: **designing such transformation mechanisms is entirely manual**. Researchers have published over 20 top-conference papers, each hand-crafting specialized oracles ‚Äî TLP, NoREC, EET, DQP ‚Äî yet bugs keep slipping through. Consider this real TiDB bug that went undetected for *years*:

```sql
CREATE TABLE t1(c INT);
INSERT INTO t1 VALUES (1);

-- Q: Empty table filter ‚Üí should return {}
SELECT c / 3 FROM t1 WHERE false;       -- {} ‚úì

-- Oracle: Q EXCEPT Q should always be empty
SELECT c / 3 FROM t1 EXCEPT SELECT c / 3 FROM t1;  -- {0.3333} ‚úó (BUG!)
```

Catching this required the very specific insight that $$Q \setminus Q = \emptyset$$. A human had to think of it. Can we make a machine do that automatically?

---

### Key Insight: Constrained Abstract Queries (CAQ)

The core innovation in Argus is a new representation called a **Constrained Abstract Query (CAQ)** ‚Äî a SQL query template with typed *placeholders* that can be filled with concrete SQL snippets.

<!-- ÔøΩ IMAGE PLACEHOLDER 2
     Âª∫ËÆÆ: ÊèíÂÖ•‰∏ÄÂº†Â±ïÁ§∫ CAQ ÁªìÊûÑÁöÑÂõæÊàñË°®Ôºå
     ÊòæÁ§∫: ‰∏Ä‰∏™Â∏¶Êúâ ‚ñ°1 ‚ä≤Expr(t1:BOOLEAN) Âíå ‚ñ°1 ‚ä≤Table(...) ËøôÊ†∑ placeholder ÁöÑ SQL Ê®°ÊùøÔºå
     ÊóÅËæπÂàóÂá∫ Placeholder Á±ªÂûãÔºàExpr / TableÔºâÂíåÂØπÂ∫îÁöÑ ConstraintÔºàËøîÂõûÂÄºÁ±ªÂûã / Ë°® schemaÔºâ„ÄÇ
     ÂèØÁî®ÂπªÁÅØÁâá‰∏≠"CAQ Definition"ÈÇ£‰∏ÄÈ°µ„ÄÇ
-->

A placeholder $$\square_i$$ can be either:
- **`Expr(TableName : SQLDatatype)`** ‚Äî any expression over a table that returns a given type (e.g., a Boolean expression over `t1`)
- **`Table(SQLTableDef)`** ‚Äî any table or subquery with a given schema

An **equivalent CAQ pair** $$(s, q_1, q_2)$$ is two CAQs that produce the *same results for every possible instantiation* of their placeholders. For example, the classic **TLP oracle** can be expressed as a CAQ pair:

```sql
-- Q‚ÇÅ: seed query
SELECT * FROM t1, ‚ñ°‚ÇÅ‚ä≤Table(...);

-- Q‚ÇÇ: TLP three-way partition
SELECT * FROM t1, ‚ñ°‚ÇÅ‚ä≤Table(...) WHERE (‚ñ°‚ÇÇ‚ä≤Expr(t1:BOOLEAN) IS TRUE)
UNION ALL
SELECT * FROM t1, ‚ñ°‚ÇÅ‚ä≤Table(...) WHERE (‚ñ°‚ÇÇ‚ä≤Expr(t1:BOOLEAN) IS FALSE)
UNION ALL
SELECT * FROM t1, ‚ñ°‚ÇÅ‚ä≤Table(...) WHERE (‚ñ°‚ÇÇ‚ä≤Expr(t1:BOOLEAN) IS NULL);

-- Instantiation examples:
-- ‚ñ°‚ÇÅ ‚Ü¶ t1 ASOF JOIN t2
-- ‚ñ°‚ÇÇ ‚Ü¶ json_valid(t1.c0)
```

The power of CAQs: one CAQ pair is a reusable oracle that can generate *thousands* of concrete test cases by filling its placeholders with diverse SQL snippets.

---

### The Argus Pipeline

<!-- üì∏ IMAGE PLACEHOLDER 3
     Âª∫ËÆÆ: ÊèíÂÖ• paper/ÂπªÁÅØÁâá‰∏≠ÁöÑ Figure 1 "Overall pipeline of Argus"Ôºå
     ËøôÂº†ÂõæÂ±ïÁ§∫‰∫Ü Argus ÁöÑ 6 ‰∏™Ê≠•È™§Ôºà‚ë†ÁîüÊàê schema Âíå seed CAQÔºå
     ‚ë°LLM ÁîüÊàêÁ≠â‰ª∑ CAQ pair Âπ∂Áî® prover È™åËØÅÔºå‚ë¢ÁîüÊàê SQL snippets corpusÔºå
     ‚ë£ÂÆû‰æãÂåñÁ≠â‰ª∑ SQL pairsÔºå‚ë§ÂÆû‰æãÂåñÊï∞ÊçÆÂ∫ìÔºå‚ë•Âú® DBMS ‰∏äÈ™åËØÅÂπ∂Êä•Âëä bugÔºâ„ÄÇ
     ËøôÊòØÂÖ®ÊñáÊúÄÊ†∏ÂøÉÁöÑÁ≥ªÁªüÂõæÔºåÂä°ÂøÖÊèíÂÖ•„ÄÇ
-->

Argus operates in two stages:

#### Stage 1 ‚Äî Test Oracle Discovery (offline, one-time)

**‚ë† Database Seeding.** A grammar-based generator (SQLancer) produces random database schemas and seed CAQs. Virtual columns and tables serve as placeholders, making the output compatible with SQL provers that expect concrete syntax.

**‚ë° LLM-based Oracle Generation + Formal Verification.** For each seed CAQ $$q$$, Argus iteratively prompts an LLM to generate an equivalent variant $$q'$$. Two mechanisms ensure quality:

- **In-context learning** ‚Äî the LLM is shown verified successes (*Equal* set) and failures (*Fail* set) from previous rounds.
- **Diversity-oriented sampling** ‚Äî verified CAQs are clustered by query-plan tree-edit distance (k-means), and samples are drawn from each cluster to push the LLM toward novel execution plans.

Every candidate $$q'$$ must pass a **SQL equivalence prover** (SQLSolver) before acceptance. Placeholders are replaced by virtual entities so the prover can reason on concrete queries. Only formally verified pairs become test oracles ‚Äî **zero false positives by design**.

#### Stage 2 ‚Äî Test Case Instantiation (online, per DBMS)

<!-- üì∏ IMAGE PLACEHOLDER 4
     Âª∫ËÆÆ: ÊèíÂÖ•‰∏Ä‰∏™Â±ïÁ§∫"corpus synthesis + instantiation"ÊµÅÁ®ãÁöÑÂõæÔºå
     ÊòæÁ§∫: SQL snippets corpusÔºàÁî± LLM + grammar-based generator Ê∑∑ÂêàÁîüÊàêÔºâÔºå
     ÁÑ∂ÂêéÈÄöËøá runtime validation ËøáÊª§ÔºåÊúÄÂêé fill into CAQ placeholders ÂæóÂà∞ concrete SQL pair„ÄÇ
     ÂèØÁî®ÂπªÁÅØÁâá‰∏≠ÂÖ≥‰∫é Phase II ÁöÑÈÇ£Âá†È°µÔºåÊàñ Algorithm 2 ÁöÑÁ§∫ÊÑèÂõæ„ÄÇ
-->

**‚ë¢ Corpus Synthesis.** A hybrid approach (LLM + grammar-based generator) pre-generates a large library of SQL snippets:
- LLMs produce *complex, feature-rich* expressions and table structures, guided by official DBMS documentation.
- The grammar-based generator covers *corner values and edge cases* systematically.
- **Cross-combination**: expressions are recursively composed (e.g., substituting a Boolean expr into an INT function that expects a Boolean column) to create intricate multi-level expressions.
- Every snippet is *runtime-validated* on the target DBMS to filter type mismatches and invalid SQL.

**‚ë£‚ë§‚ë• Instantiation & Bug Detection.** Each verified CAQ pair is instantiated up to $$K$$ times by randomly sampling compatible snippets from the corpus. Placeholders are replaced consistently in both $$q$$ and $$q'$$. Random database instances are created, and the two queries are executed. Any result mismatch is a bug report.

Three *general constraints* on snippets guarantee that instantiated pairs remain equivalent even when concrete expressions are plugged in:
1. **Determinism** ‚Äî no `RANDOM()`, `CURRENT_TIMESTAMP`, etc.
2. **Null-preserving** ‚Äî expression returns `NULL` when evaluated on all-NULL rows.
3. **Empty-result-preserving** ‚Äî expression returns empty on an empty table.

---

### Representative Bugs Found

#### PostgreSQL: Incorrect json function in RIGHT JOIN

```sql
CREATE TABLE t(c INT);
INSERT INTO t VALUES (1);

-- Q1: RIGHT JOIN with FALSE ‚Üí left side always NULL
SELECT sub.c FROM (
  SELECT json_array_length(json_array(3, 2, t.c)) AS c FROM t
) AS sub RIGHT JOIN t ON FALSE;  -- Expected: {NULL}, Got: {2} ‚úó

-- Q2: explicitly NULL in subquery
SELECT sub.c FROM (SELECT NULL AS c FROM t) AS sub
RIGHT JOIN t ON FALSE;  -- {NULL} ‚úì
```

**Root cause:** PostgreSQL's json functions bypass the null-propagation rule for RIGHT JOIN, producing incorrect non-null values. Reported and fixed within **24 hours**.

#### Dolt: EXISTS duplicates rows

```sql
CREATE TABLE t(c0 INT, c1 INT, PRIMARY KEY (c0, c1));
INSERT INTO t VALUES (1,1), (2,2), (2,3);

-- With NOT NULL primary key, EXISTS is always TRUE ‚Üí should return all rows once
SELECT * FROM t WHERE EXISTS (SELECT 1 FROM t AS x WHERE x.c0 = t.c0);
-- Got: {(1,1),(2,2),(2,3),(1,1),(2,2),(2,3)} ‚úó ‚Äî every row duplicated!

SELECT * FROM t;  -- {(1,1),(2,2),(2,3)} ‚úì
```

#### DuckDB: Empty CTE incorrectly short-circuits UNION ALL

```sql
-- Q1
SELECT t2.c0 FROM t2, t3 LEFT JOIN t1 ON false;  -- {true} ‚úì

-- Q2 (equivalent via CTE expansion)
WITH c AS (SELECT * FROM t1 WHERE false)
SELECT t2.c0 FROM t2 CROSS JOIN t3 CROSS JOIN c
UNION ALL
SELECT t2.c0 FROM t2 CROSS JOIN t3 WHERE NOT EXISTS (SELECT 1 FROM c);
-- Got: {0 rows} ‚úó
```

**Root cause:** DuckDB incorrectly assumes an empty materialized CTE always causes the outer query to return no rows ‚Äî not true with `UNION ALL`.

---

### Evaluation Results

<!-- üì∏ IMAGE PLACEHOLDER 5
     Âª∫ËÆÆ: ÊèíÂÖ• paper ‰∏≠ÁöÑ Table 2 "Argus found bugs statistics"ÁöÑÊà™ÂõæÊàñÈáçÂà∂Ë°®Ê†ºÔºå
     ÊòæÁ§∫ÂêÑ DBMSÔºàDolt, DuckDB, MySQL, PostgreSQL, TiDBÔºâÁöÑ bug Êï∞Èáè„ÄÅ
     Áä∂ÊÄÅÔºàFixed / Confirmed / Duplicate / PendingÔºâÂíåÁ±ªÂûãÔºàLogic / OtherÔºâ„ÄÇ
     ËøôÊòØÊúÄÁõ¥Êé•Â±ïÁ§∫ÊàêÊûúÁöÑË°®Ê†º„ÄÇ
-->

#### Bugs Found (5 DBMSs, 3-month campaign)

<table class="table table-sm text-center" style="width: auto; margin: 1rem auto; font-size: 0.88rem; border: 1px solid #ccc;">
  <thead style="background-color: #f0f0f0; color: var(--global-text-color); font-weight: 600;">
    <tr>
      <th class="text-start" style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px;">DBMS</th>
      <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px;">Reported</th>
      <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px;">Fixed</th>
      <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px;">Confirmed</th>
      <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px;">Logic Bugs</th>
    </tr>
  </thead>
  <tbody style="color: var(--global-text-color);">
    <tr><td class="text-start" style="border-color: #ccc; padding: 3px 10px;">Dolt</td><td style="border-color: #ccc; padding: 3px 10px;">19</td><td style="border-color: #ccc; padding: 3px 10px;">18</td><td style="border-color: #ccc; padding: 3px 10px;">19</td><td style="border-color: #ccc; padding: 3px 10px;">18</td></tr>
    <tr><td class="text-start" style="border-color: #ccc; padding: 3px 10px;">DuckDB</td><td style="border-color: #ccc; padding: 3px 10px;">8</td><td style="border-color: #ccc; padding: 3px 10px;">6</td><td style="border-color: #ccc; padding: 3px 10px;">7</td><td style="border-color: #ccc; padding: 3px 10px;">4</td></tr>
    <tr><td class="text-start" style="border-color: #ccc; padding: 3px 10px;">MySQL</td><td style="border-color: #ccc; padding: 3px 10px;">8</td><td style="border-color: #ccc; padding: 3px 10px;">0</td><td style="border-color: #ccc; padding: 3px 10px;">5</td><td style="border-color: #ccc; padding: 3px 10px;">8</td></tr>
    <tr><td class="text-start" style="border-color: #ccc; padding: 3px 10px;">PostgreSQL</td><td style="border-color: #ccc; padding: 3px 10px;">1</td><td style="border-color: #ccc; padding: 3px 10px;">1</td><td style="border-color: #ccc; padding: 3px 10px;">1</td><td style="border-color: #ccc; padding: 3px 10px;">1</td></tr>
    <tr><td class="text-start" style="border-color: #ccc; padding: 3px 10px;">TiDB</td><td style="border-color: #ccc; padding: 3px 10px;">5</td><td style="border-color: #ccc; padding: 3px 10px;">2</td><td style="border-color: #ccc; padding: 3px 10px;">5</td><td style="border-color: #ccc; padding: 3px 10px;">5</td></tr>
    <tr style="font-weight: 700; border-top: 2px solid #ccc;"><td class="text-start" style="border-color: #ccc; padding: 3px 10px;">Total</td><td style="border-color: #ccc; padding: 3px 10px;">41</td><td style="border-color: #ccc; padding: 3px 10px;">27</td><td style="border-color: #ccc; padding: 3px 10px;">36</td><td style="border-color: #ccc; padding: 3px 10px;">36</td></tr>
  </tbody>
</table>

36 out of 41 bugs are **logic bugs** ‚Äî the silent, most dangerous class that cause incorrect query results without any error. Compared to recent works finding 21, 24, 35 logic bugs with manually crafted oracles, Argus finds *more* despite targeting DBMSs already extensively tested.

#### Code Coverage

<!-- üì∏ IMAGE PLACEHOLDER 6
     Âª∫ËÆÆ: ÊèíÂÖ• paper ‰∏≠ÁöÑ Figure 3 "Code coverage" ÂõõÊ†ºÂõæÔºàDuckDB line/branchÔºåPostgreSQL line/branchÔºâÔºå
     Â±ïÁ§∫ Argus vs SQLancer vs SQLancer++ vs EET Âú® 24 Â∞èÊó∂ÊµãËØï‰∏≠ÁöÑ line/branch coverage Êõ≤Á∫ø„ÄÇ
     ËøôÊòØ coverage ÂØπÊØîÁöÑÊ†∏ÂøÉÂõæ„ÄÇ
-->

On **DuckDB** (24-hour run):
- Argus achieves **+19.9% line coverage** and **+18.1% branch coverage** over SQLancer++
- **5.5√ó line** and **6.4√ó function** metamorphic coverage over SQLancer ‚Äî *metamorphic coverage* measures how much code is exercised *differently* between the two equivalent queries, directly correlating with logic bug-finding ability

On **PostgreSQL**:
- Outperforms SQLancer++ by **+19.0% line** and **+22.5% branch** coverage
- Covers **23 query features** (vs SQLancer's 15 in pglast), demonstrating the LLM's ability to generate feature-rich queries

#### New Oracles vs. Prior Manual Oracles

<!-- üì∏ IMAGE PLACEHOLDER 7
     Âª∫ËÆÆ: ÊèíÂÖ• paper ‰∏≠ÁöÑ Figure 4ÔºåÂ±ïÁ§∫Âú® Dolt v1.0.0 ‰∏ä 6 Â∞èÊó∂ÊµãËØï‰∏≠
     Argus-5000 / Argus-50 / BaselineÔºàTLP+NoREC+EET+DQP ÂÖ± 11 ‰∏™ÊâãÂ∑• oracleÔºâ
     ÊâæÂà∞ÁöÑ unique logic bugs Êï∞ÈáèÈöèÊó∂Èó¥ÁöÑÂèòÂåñÊõ≤Á∫ø„ÄÇ
     Argus-5000 ÊâæÂà∞ 10 ‰∏™Ôºåbaseline Âè™ÊâæÂà∞ 3 ‰∏™„ÄÇ
-->

In a head-to-head comparison on Dolt v1.0.0 (6-hour window), using **the same snippet corpus and CAQ format** for fairness:
- **Argus-5,000 oracles**: found **10 unique logic bugs**
- **Baseline** (union of TLP + NoREC + EET + DQP ‚Äî 11 hand-crafted oracles): found **3**
- Argus-50 oracles (fewer than baseline): found only 2, confirming the *quantity* of oracles matters

The **3.33√ó improvement** demonstrates that automation unlocks oracle diversity that manual design simply cannot match at scale.

#### Cost & Efficiency

<!-- üì∏ IMAGE PLACEHOLDER 8
     Âª∫ËÆÆ: ÊèíÂÖ• paper ‰∏≠ÁöÑ Figure 5 "Cost and efficiency comparison"Ôºå
     ÊòæÁ§∫ ArgusÔºàPhase I CAQ ÁîüÊàê + Phase II ÂÆû‰æãÂåñÔºâvs Êú¥Á¥† baseline Âú® 1 Â∞èÊó∂ÂÜÖ
     Á¥ØËÆ°ÁîüÊàê test case Êï∞ÈáèÔºày ËΩ¥ log scaleÔºâÂíåÁ¥ØËÆ° LLM Ë¥πÁî®ÔºàÂè≥ y ËΩ¥ÔºâÁöÑÂØπÊØîÊõ≤Á∫ø„ÄÇ
     Argus Âú®Âá†ÂàÜÈíüÂÜÖÂÆåÊàê Phase I ÂêéÔºåPhase II ÁöÑ throughput ËøúÈ´ò‰∫é baseline„ÄÇ
-->

Argus's two-stage design is *dramatically* more efficient than a naive LLM baseline that generates full concrete query pairs directly:

<table class="table table-sm" style="width: auto; margin: 1rem auto; font-size: 0.88rem; border: 1px solid #ccc;">
  <thead style="background-color: #f0f0f0; color: var(--global-text-color); font-weight: 600;">
    <tr>
      <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px;">Cost Item</th>
      <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px;">Argus</th>
    </tr>
  </thead>
  <tbody style="color: var(--global-text-color);">
    <tr><td style="border-color: #ccc; padding: 3px 10px;">CAQ pair generation (Phase I)</td><td style="border-color: #ccc; padding: 3px 10px;">~$3</td></tr>
    <tr><td style="border-color: #ccc; padding: 3px 10px;">Snippet corpus (100,000 snippets)</td><td style="border-color: #ccc; padding: 3px 10px;">~$12</td></tr>
    <tr><td style="border-color: #ccc; padding: 3px 10px;">Instantiation</td><td style="border-color: #ccc; padding: 3px 10px;">~$1 / 1,000 test cases</td></tr>
  </tbody>
</table>

The naive baseline generates test cases orders of magnitude more slowly because it must call the LLM for every single test case.

#### Soundness: Why the SQL Prover Matters

<!-- üì∏ IMAGE PLACEHOLDER 9
     Âª∫ËÆÆ: ÊèíÂÖ•‰∏ÄÂº†ÂØπÊØîÂõæÊàñË°®Ê†ºÔºåÂ±ïÁ§∫ LLM-as-a-judge vs SQL equivalence prover ÁöÑÊïàÊûúÂØπÊØîÔºå
     Ê†∏ÂøÉÊï∞ÊçÆ: LLM-as-a-judge ‰∫ßÁîüÁöÑ 20 ‰∏™ bug report ÂÖ®ÈÉ®ÊòØ false positiveÔºà0 ‰∏™Áúü bugÔºâÔºå
     ËÄå prover È™åËØÅÁöÑ oracle ‰∫ßÁîüÁöÑ bug report ÂÖ®ÈÉ®ÊòØÁúü bugÔºà0 false positiveÔºâ„ÄÇ
     ÂèØ‰ª•ÊòØÂπªÁÅØÁâá‰∏≠ÂØπÂ∫îÁöÑÂØπÊØî slide Êà™Âõæ„ÄÇ
-->

When we replaced the SQL equivalence prover with **LLM-as-a-judge** (using GPT-4):
- 20 consecutive bug reports were **all false positives**
- Among 20 LLM-judged-equivalent CAQ pairs, 1 was actually inequivalent (5% error rate)

In mature DBMSs, finding a single real bug may require *thousands* of queries. Even a 5% error rate overwhelmingly drowns out true bugs. The prover is not optional ‚Äî it's what makes Argus *practical*.

---

### What Makes Argus Different

<table class="table table-sm" style="width: auto; margin: 1rem auto; font-size: 0.88rem; border: 1px solid #ccc;">
  <thead style="background-color: #f0f0f0; color: var(--global-text-color); font-weight: 600;">
    <tr>
      <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px;">Aspect</th>
      <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px;">Prior work</th>
      <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px;">Argus</th>
    </tr>
  </thead>
  <tbody style="color: var(--global-text-color);">
    <tr><td style="border-color: #ccc; padding: 3px 10px;">Oracle design</td><td style="border-color: #ccc; padding: 3px 10px;">Manual, expert-crafted</td><td style="border-color: #ccc; padding: 3px 10px;">Automated by LLM</td></tr>
    <tr><td style="border-color: #ccc; padding: 3px 10px;">Soundness</td><td style="border-color: #ccc; padding: 3px 10px;">Assumed correct</td><td style="border-color: #ccc; padding: 3px 10px;">Formally verified by SQL prover</td></tr>
    <tr><td style="border-color: #ccc; padding: 3px 10px;">Scalability</td><td style="border-color: #ccc; padding: 3px 10px;">~10s of hand-written oracles</td><td style="border-color: #ccc; padding: 3px 10px;">Thousands of verified CAQ pairs</td></tr>
    <tr><td style="border-color: #ccc; padding: 3px 10px;">Test case generation</td><td style="border-color: #ccc; padding: 3px 10px;">Direct LLM calls (slow)</td><td style="border-color: #ccc; padding: 3px 10px;">Reusable corpus (fast)</td></tr>
    <tr><td style="border-color: #ccc; padding: 3px 10px;">Metamorphic coverage</td><td style="border-color: #ccc; padding: 3px 10px;">Limited by human creativity</td><td style="border-color: #ccc; padding: 3px 10px;">5‚Äì6√ó higher than state-of-the-art</td></tr>
  </tbody>
</table>

---

### Discussion

**Prover limitations are opportunities.** SQL equivalence provers currently support a subset of SQL features (core Calcite syntax: outer joins, nested queries, basic aggregations). Argus's two-stage design mitigates this by *proving equivalence at the abstract CAQ level*, then instantiating placeholders with complex, DBMS-specific snippets that go beyond the prover's reasoning capabilities.

**We also found prover bugs.** During development, Argus revealed **10 bugs in SQLSolver and QED** ‚Äî incorrect equivalence proofs that would have caused false positives. All were fixed quickly. Improving Argus simultaneously improves the tools it depends on.

**Extensible by design.** Argus can be steered toward specific SQL features simply by adjusting the LLM prompt (e.g., "ensure the generated snippet includes at least one OUTER JOIN"). No code changes needed.

**Future directions.** Two natural extensions:
1. Expand beyond relational DBMSs and SELECT queries (graph DBs, spatial DBs, DML statements).
2. Develop oracle *prioritization* ‚Äî given thousands of LLM-generated oracles, which are most likely to find bugs?

---

### Citation

```bibtex
@article{mang2026argus,
  title     = {Automated Discovery of Test Oracles for Database Management Systems Using LLMs},
  author    = {Qiuyang Mang and Runyuan He and Suyang Zhong and Xiaoxuan Liu and Huanchen Zhang and Alvin Cheung},
  journal   = {Proc. ACM Manag. Data},
  volume    = {4},
  number    = {3},
  year      = {2026},
  publisher = {ACM}
}
```
