<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://joyemang33.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://joyemang33.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2026-02-23T23:09:56+00:00</updated><id>https://joyemang33.github.io/feed.xml</id><title type="html">blank</title><subtitle>A undergraduate student in Testing, Database, Graph. </subtitle><entry><title type="html">Argus: Automated Discovery of Test Oracles for Database Management Systems Using LLMs</title><link href="https://joyemang33.github.io/blog/2026/argus/" rel="alternate" type="text/html" title="Argus: Automated Discovery of Test Oracles for Database Management Systems Using LLMs"/><published>2026-02-23T00:00:00+00:00</published><updated>2026-02-23T00:00:00+00:00</updated><id>https://joyemang33.github.io/blog/2026/argus</id><content type="html" xml:base="https://joyemang33.github.io/blog/2026/argus/"><![CDATA[<p>This work was accepted at <a href="https://2026.sigmod.org/">SIGMOD 2026</a>. <a href="https://arxiv.org/abs/2510.06663">[arXiv]</a> <a href="/assets/pdf/argus.pdf">[Slides]</a></p> <hr/> <h3 id="tldr">TL;DR</h3> <p>Database Management Systems (DBMSs) are notoriously hard to test because you need a <em>test oracle</em> — a way to know if the output is correct. Prior work builds these oracles <strong>by hand</strong>, creating a never-ending cycle of manual effort.</p> <p><strong>Argus</strong> breaks this cycle by using LLMs to <em>automatically discover</em> test oracles, then formally <em>verifies</em> them with a SQL equivalence prover for soundness, and efficiently <em>instantiates</em> them into thousands of concrete test cases. Evaluated on five heavily-tested DBMSs, Argus found <strong>41 previously unknown bugs</strong> (36 logic bugs), outperforming state-of-the-art manual oracle designs.</p> <hr/> <h3 id="the-problem-test-oracles-are-a-bottleneck">The Problem: Test Oracles Are a Bottleneck</h3> <p>When testing a DBMS, how do you know if the result of a SQL query is <em>correct</em>? This is the <strong>test oracle problem</strong>. A naive approach would be to compare two DBMSs against each other, but that misses bugs they share. The dominant approach instead builds <em>semantic equivalence oracles</em>: transform a query \(Q\) into a semantically equivalent \(Q'\), run both, and flag inconsistencies as bugs.</p> <p>The catch: <strong>designing such transformation mechanisms is entirely manual</strong>. Researchers have published over 20 top-conference papers, each hand-crafting specialized oracles — TLP, NoREC, EET, DQP — yet bugs keep slipping through. Consider this real TiDB bug that went undetected for <em>years</em>:</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">t1</span><span class="p">(</span><span class="k">c</span> <span class="nb">INT</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">t1</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">-- Q: Empty table filter → should return {}</span>
<span class="k">SELECT</span> <span class="k">c</span> <span class="o">/</span> <span class="mi">3</span> <span class="k">FROM</span> <span class="n">t1</span> <span class="k">WHERE</span> <span class="k">false</span><span class="p">;</span>       <span class="c1">-- {} ✓</span>

<span class="c1">-- Oracle: Q EXCEPT Q should always be empty</span>
<span class="k">SELECT</span> <span class="k">c</span> <span class="o">/</span> <span class="mi">3</span> <span class="k">FROM</span> <span class="n">t1</span> <span class="k">EXCEPT</span> <span class="k">SELECT</span> <span class="k">c</span> <span class="o">/</span> <span class="mi">3</span> <span class="k">FROM</span> <span class="n">t1</span><span class="p">;</span>  <span class="c1">-- {0.3333} ✗ (BUG!)</span>
</code></pre></div></div> <p>Catching this required the very specific insight that \(Q \setminus Q = \emptyset\). A human had to think of it. Can we make a machine do that automatically?</p> <hr/> <h3 id="key-insight-constrained-abstract-queries-caq">Key Insight: Constrained Abstract Queries (CAQ)</h3> <p>The core innovation in Argus is a new representation called a <strong>Constrained Abstract Query (CAQ)</strong> — a SQL query template with typed <em>placeholders</em> that can be filled with concrete SQL snippets.</p> <p>A placeholder \(\square_i\) can be either:</p> <ul> <li><strong><code class="language-plaintext highlighter-rouge">Expr(TableName : SQLDatatype)</code></strong> — any expression over a table that returns a given type (e.g., a Boolean expression over <code class="language-plaintext highlighter-rouge">t1</code>)</li> <li><strong><code class="language-plaintext highlighter-rouge">Table(SQLTableDef)</code></strong> — any table or subquery with a given schema</li> </ul> <p>An <strong>equivalent CAQ pair</strong> \((s, q_1, q_2)\) is two CAQs that produce the <em>same results for every possible instantiation</em> of their placeholders. For example, the classic <strong>TLP oracle</strong> can be expressed as a CAQ pair:</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- Q₁: seed query</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">t1</span><span class="p">,</span> <span class="err">□₁⊲</span><span class="k">Table</span><span class="p">(...);</span>

<span class="c1">-- Q₂: TLP three-way partition</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">t1</span><span class="p">,</span> <span class="err">□₁⊲</span><span class="k">Table</span><span class="p">(...)</span> <span class="k">WHERE</span> <span class="p">(</span><span class="err">□₂⊲</span><span class="n">Expr</span><span class="p">(</span><span class="n">t1</span><span class="p">:</span><span class="nb">BOOLEAN</span><span class="p">)</span> <span class="k">IS</span> <span class="k">TRUE</span><span class="p">)</span>
<span class="k">UNION</span> <span class="k">ALL</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">t1</span><span class="p">,</span> <span class="err">□₁⊲</span><span class="k">Table</span><span class="p">(...)</span> <span class="k">WHERE</span> <span class="p">(</span><span class="err">□₂⊲</span><span class="n">Expr</span><span class="p">(</span><span class="n">t1</span><span class="p">:</span><span class="nb">BOOLEAN</span><span class="p">)</span> <span class="k">IS</span> <span class="k">FALSE</span><span class="p">)</span>
<span class="k">UNION</span> <span class="k">ALL</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">t1</span><span class="p">,</span> <span class="err">□₁⊲</span><span class="k">Table</span><span class="p">(...)</span> <span class="k">WHERE</span> <span class="p">(</span><span class="err">□₂⊲</span><span class="n">Expr</span><span class="p">(</span><span class="n">t1</span><span class="p">:</span><span class="nb">BOOLEAN</span><span class="p">)</span> <span class="k">IS</span> <span class="k">NULL</span><span class="p">);</span>

<span class="c1">-- Instantiation examples:</span>
<span class="c1">-- □₁ ↦ t1 ASOF JOIN t2</span>
<span class="c1">-- □₂ ↦ json_valid(t1.c0)</span>
</code></pre></div></div> <p>The power of CAQs: one CAQ pair is a reusable oracle that can generate <em>thousands</em> of concrete test cases by filling its placeholders with diverse SQL snippets.</p> <hr/> <h3 id="the-argus-pipeline">The Argus Pipeline</h3> <p>Argus operates in two stages:</p> <h4 id="stage-1--test-oracle-discovery-offline-one-time">Stage 1 — Test Oracle Discovery (offline, one-time)</h4> <p><strong>① Database Seeding.</strong> A grammar-based generator (SQLancer) produces random database schemas and seed CAQs. Virtual columns and tables serve as placeholders, making the output compatible with SQL provers that expect concrete syntax.</p> <p><strong>② LLM-based Oracle Generation + Formal Verification.</strong> For each seed CAQ \(q\), Argus iteratively prompts an LLM to generate an equivalent variant \(q'\). Two mechanisms ensure quality:</p> <ul> <li><strong>In-context learning</strong> — the LLM is shown verified successes (<em>Equal</em> set) and failures (<em>Fail</em> set) from previous rounds.</li> <li><strong>Diversity-oriented sampling</strong> — verified CAQs are clustered by query-plan tree-edit distance (k-means), and samples are drawn from each cluster to push the LLM toward novel execution plans.</li> </ul> <p>Every candidate \(q'\) must pass a <strong>SQL equivalence prover</strong> (SQLSolver) before acceptance. Placeholders are replaced by virtual entities so the prover can reason on concrete queries. Only formally verified pairs become test oracles — <strong>zero false positives by design</strong>.</p> <h4 id="stage-2--test-case-instantiation-online-per-dbms">Stage 2 — Test Case Instantiation (online, per DBMS)</h4> <p><strong>③ Corpus Synthesis.</strong> A hybrid approach (LLM + grammar-based generator) pre-generates a large library of SQL snippets:</p> <ul> <li>LLMs produce <em>complex, feature-rich</em> expressions and table structures, guided by official DBMS documentation.</li> <li>The grammar-based generator covers <em>corner values and edge cases</em> systematically.</li> <li><strong>Cross-combination</strong>: expressions are recursively composed (e.g., substituting a Boolean expr into an INT function that expects a Boolean column) to create intricate multi-level expressions.</li> <li>Every snippet is <em>runtime-validated</em> on the target DBMS to filter type mismatches and invalid SQL.</li> </ul> <p><strong>④⑤⑥ Instantiation &amp; Bug Detection.</strong> Each verified CAQ pair is instantiated up to \(K\) times by randomly sampling compatible snippets from the corpus. Placeholders are replaced consistently in both \(q\) and \(q'\). Random database instances are created, and the two queries are executed. Any result mismatch is a bug report.</p> <p>Three <em>general constraints</em> on snippets guarantee that instantiated pairs remain equivalent even when concrete expressions are plugged in:</p> <ol> <li><strong>Determinism</strong> — no <code class="language-plaintext highlighter-rouge">RANDOM()</code>, <code class="language-plaintext highlighter-rouge">CURRENT_TIMESTAMP</code>, etc.</li> <li><strong>Null-preserving</strong> — expression returns <code class="language-plaintext highlighter-rouge">NULL</code> when evaluated on all-NULL rows.</li> <li><strong>Empty-result-preserving</strong> — expression returns empty on an empty table.</li> </ol> <hr/> <h3 id="representative-bugs-found">Representative Bugs Found</h3> <h4 id="postgresql-incorrect-json-function-in-right-join">PostgreSQL: Incorrect json function in RIGHT JOIN</h4> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">t</span><span class="p">(</span><span class="k">c</span> <span class="nb">INT</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">t</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">-- Q1: RIGHT JOIN with FALSE → left side always NULL</span>
<span class="k">SELECT</span> <span class="n">sub</span><span class="p">.</span><span class="k">c</span> <span class="k">FROM</span> <span class="p">(</span>
  <span class="k">SELECT</span> <span class="n">json_array_length</span><span class="p">(</span><span class="n">json_array</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">.</span><span class="k">c</span><span class="p">))</span> <span class="k">AS</span> <span class="k">c</span> <span class="k">FROM</span> <span class="n">t</span>
<span class="p">)</span> <span class="k">AS</span> <span class="n">sub</span> <span class="k">RIGHT</span> <span class="k">JOIN</span> <span class="n">t</span> <span class="k">ON</span> <span class="k">FALSE</span><span class="p">;</span>  <span class="c1">-- Expected: {NULL}, Got: {2} ✗</span>

<span class="c1">-- Q2: explicitly NULL in subquery</span>
<span class="k">SELECT</span> <span class="n">sub</span><span class="p">.</span><span class="k">c</span> <span class="k">FROM</span> <span class="p">(</span><span class="k">SELECT</span> <span class="k">NULL</span> <span class="k">AS</span> <span class="k">c</span> <span class="k">FROM</span> <span class="n">t</span><span class="p">)</span> <span class="k">AS</span> <span class="n">sub</span>
<span class="k">RIGHT</span> <span class="k">JOIN</span> <span class="n">t</span> <span class="k">ON</span> <span class="k">FALSE</span><span class="p">;</span>  <span class="c1">-- {NULL} ✓</span>
</code></pre></div></div> <p><strong>Root cause:</strong> PostgreSQL’s json functions bypass the null-propagation rule for RIGHT JOIN, producing incorrect non-null values. Reported and fixed within <strong>24 hours</strong>.</p> <h4 id="dolt-exists-duplicates-rows">Dolt: EXISTS duplicates rows</h4> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">t</span><span class="p">(</span><span class="n">c0</span> <span class="nb">INT</span><span class="p">,</span> <span class="n">c1</span> <span class="nb">INT</span><span class="p">,</span> <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">c0</span><span class="p">,</span> <span class="n">c1</span><span class="p">));</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">t</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>

<span class="c1">-- With NOT NULL primary key, EXISTS is always TRUE → should return all rows once</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">t</span> <span class="k">WHERE</span> <span class="k">EXISTS</span> <span class="p">(</span><span class="k">SELECT</span> <span class="mi">1</span> <span class="k">FROM</span> <span class="n">t</span> <span class="k">AS</span> <span class="n">x</span> <span class="k">WHERE</span> <span class="n">x</span><span class="p">.</span><span class="n">c0</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">c0</span><span class="p">);</span>
<span class="c1">-- Got: {(1,1),(2,2),(2,3),(1,1),(2,2),(2,3)} ✗ — every row duplicated!</span>

<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">t</span><span class="p">;</span>  <span class="c1">-- {(1,1),(2,2),(2,3)} ✓</span>
</code></pre></div></div> <h4 id="duckdb-empty-cte-incorrectly-short-circuits-union-all">DuckDB: Empty CTE incorrectly short-circuits UNION ALL</h4> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- Q1</span>
<span class="k">SELECT</span> <span class="n">t2</span><span class="p">.</span><span class="n">c0</span> <span class="k">FROM</span> <span class="n">t2</span><span class="p">,</span> <span class="n">t3</span> <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">t1</span> <span class="k">ON</span> <span class="k">false</span><span class="p">;</span>  <span class="c1">-- {true} ✓</span>

<span class="c1">-- Q2 (equivalent via CTE expansion)</span>
<span class="k">WITH</span> <span class="k">c</span> <span class="k">AS</span> <span class="p">(</span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">t1</span> <span class="k">WHERE</span> <span class="k">false</span><span class="p">)</span>
<span class="k">SELECT</span> <span class="n">t2</span><span class="p">.</span><span class="n">c0</span> <span class="k">FROM</span> <span class="n">t2</span> <span class="k">CROSS</span> <span class="k">JOIN</span> <span class="n">t3</span> <span class="k">CROSS</span> <span class="k">JOIN</span> <span class="k">c</span>
<span class="k">UNION</span> <span class="k">ALL</span>
<span class="k">SELECT</span> <span class="n">t2</span><span class="p">.</span><span class="n">c0</span> <span class="k">FROM</span> <span class="n">t2</span> <span class="k">CROSS</span> <span class="k">JOIN</span> <span class="n">t3</span> <span class="k">WHERE</span> <span class="k">NOT</span> <span class="k">EXISTS</span> <span class="p">(</span><span class="k">SELECT</span> <span class="mi">1</span> <span class="k">FROM</span> <span class="k">c</span><span class="p">);</span>
<span class="c1">-- Got: {0 rows} ✗</span>
</code></pre></div></div> <p><strong>Root cause:</strong> DuckDB incorrectly assumes an empty materialized CTE always causes the outer query to return no rows — not true with <code class="language-plaintext highlighter-rouge">UNION ALL</code>.</p> <hr/> <h3 id="evaluation-results">Evaluation Results</h3> <h4 id="bugs-found-5-dbmss-3-month-campaign">Bugs Found (5 DBMSs, 3-month campaign)</h4> <table class="table table-sm text-center" style="width: auto; margin: 1rem auto; font-size: 0.88rem; border: 1px solid #ccc;"> <thead style="background-color: #f0f0f0; color: var(--global-text-color); font-weight: 600;"> <tr> <th class="text-start" style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px;">DBMS</th> <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px;">Reported</th> <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px;">Fixed</th> <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px;">Confirmed</th> <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px;">Logic Bugs</th> </tr> </thead> <tbody style="color: var(--global-text-color);"> <tr><td class="text-start" style="border-color: #ccc; padding: 3px 10px;">Dolt</td><td style="border-color: #ccc; padding: 3px 10px;">19</td><td style="border-color: #ccc; padding: 3px 10px;">18</td><td style="border-color: #ccc; padding: 3px 10px;">19</td><td style="border-color: #ccc; padding: 3px 10px;">18</td></tr> <tr><td class="text-start" style="border-color: #ccc; padding: 3px 10px;">DuckDB</td><td style="border-color: #ccc; padding: 3px 10px;">8</td><td style="border-color: #ccc; padding: 3px 10px;">6</td><td style="border-color: #ccc; padding: 3px 10px;">7</td><td style="border-color: #ccc; padding: 3px 10px;">4</td></tr> <tr><td class="text-start" style="border-color: #ccc; padding: 3px 10px;">MySQL</td><td style="border-color: #ccc; padding: 3px 10px;">8</td><td style="border-color: #ccc; padding: 3px 10px;">0</td><td style="border-color: #ccc; padding: 3px 10px;">5</td><td style="border-color: #ccc; padding: 3px 10px;">8</td></tr> <tr><td class="text-start" style="border-color: #ccc; padding: 3px 10px;">PostgreSQL</td><td style="border-color: #ccc; padding: 3px 10px;">1</td><td style="border-color: #ccc; padding: 3px 10px;">1</td><td style="border-color: #ccc; padding: 3px 10px;">1</td><td style="border-color: #ccc; padding: 3px 10px;">1</td></tr> <tr><td class="text-start" style="border-color: #ccc; padding: 3px 10px;">TiDB</td><td style="border-color: #ccc; padding: 3px 10px;">5</td><td style="border-color: #ccc; padding: 3px 10px;">2</td><td style="border-color: #ccc; padding: 3px 10px;">5</td><td style="border-color: #ccc; padding: 3px 10px;">5</td></tr> <tr style="font-weight: 700; border-top: 2px solid #ccc;"><td class="text-start" style="border-color: #ccc; padding: 3px 10px;">Total</td><td style="border-color: #ccc; padding: 3px 10px;">41</td><td style="border-color: #ccc; padding: 3px 10px;">27</td><td style="border-color: #ccc; padding: 3px 10px;">36</td><td style="border-color: #ccc; padding: 3px 10px;">36</td></tr> </tbody> </table> <p>36 out of 41 bugs are <strong>logic bugs</strong> — the silent, most dangerous class that cause incorrect query results without any error. Compared to recent works finding 21, 24, 35 logic bugs with manually crafted oracles, Argus finds <em>more</em> despite targeting DBMSs already extensively tested.</p> <h4 id="code-coverage">Code Coverage</h4> <p>On <strong>DuckDB</strong> (24-hour run):</p> <ul> <li>Argus achieves <strong>+19.9% line coverage</strong> and <strong>+18.1% branch coverage</strong> over SQLancer++</li> <li><strong>5.5× line</strong> and <strong>6.4× function</strong> metamorphic coverage over SQLancer — <em>metamorphic coverage</em> measures how much code is exercised <em>differently</em> between the two equivalent queries, directly correlating with logic bug-finding ability</li> </ul> <p>On <strong>PostgreSQL</strong>:</p> <ul> <li>Outperforms SQLancer++ by <strong>+19.0% line</strong> and <strong>+22.5% branch</strong> coverage</li> <li>Covers <strong>23 query features</strong> (vs SQLancer’s 15 in pglast), demonstrating the LLM’s ability to generate feature-rich queries</li> </ul> <h4 id="new-oracles-vs-prior-manual-oracles">New Oracles vs. Prior Manual Oracles</h4> <p>In a head-to-head comparison on Dolt v1.0.0 (6-hour window), using <strong>the same snippet corpus and CAQ format</strong> for fairness:</p> <ul> <li><strong>Argus-5,000 oracles</strong>: found <strong>10 unique logic bugs</strong></li> <li><strong>Baseline</strong> (union of TLP + NoREC + EET + DQP — 11 hand-crafted oracles): found <strong>3</strong></li> <li>Argus-50 oracles (fewer than baseline): found only 2, confirming the <em>quantity</em> of oracles matters</li> </ul> <p>The <strong>3.33× improvement</strong> demonstrates that automation unlocks oracle diversity that manual design simply cannot match at scale.</p> <h4 id="cost--efficiency">Cost &amp; Efficiency</h4> <p>Argus’s two-stage design is <em>dramatically</em> more efficient than a naive LLM baseline that generates full concrete query pairs directly:</p> <table class="table table-sm" style="width: auto; margin: 1rem auto; font-size: 0.88rem; border: 1px solid #ccc;"> <thead style="background-color: #f0f0f0; color: var(--global-text-color); font-weight: 600;"> <tr> <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px;">Cost Item</th> <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px;">Argus</th> </tr> </thead> <tbody style="color: var(--global-text-color);"> <tr><td style="border-color: #ccc; padding: 3px 10px;">CAQ pair generation (Phase I)</td><td style="border-color: #ccc; padding: 3px 10px;">~$3</td></tr> <tr><td style="border-color: #ccc; padding: 3px 10px;">Snippet corpus (100,000 snippets)</td><td style="border-color: #ccc; padding: 3px 10px;">~$12</td></tr> <tr><td style="border-color: #ccc; padding: 3px 10px;">Instantiation</td><td style="border-color: #ccc; padding: 3px 10px;">~$1 / 1,000 test cases</td></tr> </tbody> </table> <p>The naive baseline generates test cases orders of magnitude more slowly because it must call the LLM for every single test case.</p> <h4 id="soundness-why-the-sql-prover-matters">Soundness: Why the SQL Prover Matters</h4> <p>When we replaced the SQL equivalence prover with <strong>LLM-as-a-judge</strong> (using GPT-4):</p> <ul> <li>20 consecutive bug reports were <strong>all false positives</strong></li> <li>Among 20 LLM-judged-equivalent CAQ pairs, 1 was actually inequivalent (5% error rate)</li> </ul> <p>In mature DBMSs, finding a single real bug may require <em>thousands</em> of queries. Even a 5% error rate overwhelmingly drowns out true bugs. The prover is not optional — it’s what makes Argus <em>practical</em>.</p> <hr/> <h3 id="what-makes-argus-different">What Makes Argus Different</h3> <table class="table table-sm" style="width: auto; margin: 1rem auto; font-size: 0.88rem; border: 1px solid #ccc;"> <thead style="background-color: #f0f0f0; color: var(--global-text-color); font-weight: 600;"> <tr> <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px;">Aspect</th> <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px;">Prior work</th> <th style="background-color: #f0f0f0; border-color: #ccc; padding: 4px 10px;">Argus</th> </tr> </thead> <tbody style="color: var(--global-text-color);"> <tr><td style="border-color: #ccc; padding: 3px 10px;">Oracle design</td><td style="border-color: #ccc; padding: 3px 10px;">Manual, expert-crafted</td><td style="border-color: #ccc; padding: 3px 10px;">Automated by LLM</td></tr> <tr><td style="border-color: #ccc; padding: 3px 10px;">Soundness</td><td style="border-color: #ccc; padding: 3px 10px;">Assumed correct</td><td style="border-color: #ccc; padding: 3px 10px;">Formally verified by SQL prover</td></tr> <tr><td style="border-color: #ccc; padding: 3px 10px;">Scalability</td><td style="border-color: #ccc; padding: 3px 10px;">~10s of hand-written oracles</td><td style="border-color: #ccc; padding: 3px 10px;">Thousands of verified CAQ pairs</td></tr> <tr><td style="border-color: #ccc; padding: 3px 10px;">Test case generation</td><td style="border-color: #ccc; padding: 3px 10px;">Direct LLM calls (slow)</td><td style="border-color: #ccc; padding: 3px 10px;">Reusable corpus (fast)</td></tr> <tr><td style="border-color: #ccc; padding: 3px 10px;">Metamorphic coverage</td><td style="border-color: #ccc; padding: 3px 10px;">Limited by human creativity</td><td style="border-color: #ccc; padding: 3px 10px;">5–6× higher than state-of-the-art</td></tr> </tbody> </table> <hr/> <h3 id="discussion">Discussion</h3> <p><strong>Prover limitations are opportunities.</strong> SQL equivalence provers currently support a subset of SQL features (core Calcite syntax: outer joins, nested queries, basic aggregations). Argus’s two-stage design mitigates this by <em>proving equivalence at the abstract CAQ level</em>, then instantiating placeholders with complex, DBMS-specific snippets that go beyond the prover’s reasoning capabilities.</p> <p><strong>We also found prover bugs.</strong> During development, Argus revealed <strong>10 bugs in SQLSolver and QED</strong> — incorrect equivalence proofs that would have caused false positives. All were fixed quickly. Improving Argus simultaneously improves the tools it depends on.</p> <p><strong>Extensible by design.</strong> Argus can be steered toward specific SQL features simply by adjusting the LLM prompt (e.g., “ensure the generated snippet includes at least one OUTER JOIN”). No code changes needed.</p> <p><strong>Future directions.</strong> Two natural extensions:</p> <ol> <li>Expand beyond relational DBMSs and SELECT queries (graph DBs, spatial DBs, DML statements).</li> <li>Develop oracle <em>prioritization</em> — given thousands of LLM-generated oracles, which are most likely to find bugs?</li> </ol> <hr/> <h3 id="citation">Citation</h3> <div class="language-bibtex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">@article</span><span class="p">{</span><span class="nl">mang2026argus</span><span class="p">,</span>
  <span class="na">title</span>     <span class="p">=</span> <span class="s">{Automated Discovery of Test Oracles for Database Management Systems Using LLMs}</span><span class="p">,</span>
  <span class="na">author</span>    <span class="p">=</span> <span class="s">{Qiuyang Mang and Runyuan He and Suyang Zhong and Xiaoxuan Liu and Huanchen Zhang and Alvin Cheung}</span><span class="p">,</span>
  <span class="na">journal</span>   <span class="p">=</span> <span class="s">{Proc. ACM Manag. Data}</span><span class="p">,</span>
  <span class="na">volume</span>    <span class="p">=</span> <span class="s">{4}</span><span class="p">,</span>
  <span class="na">number</span>    <span class="p">=</span> <span class="s">{3}</span><span class="p">,</span>
  <span class="na">year</span>      <span class="p">=</span> <span class="s">{2026}</span><span class="p">,</span>
  <span class="na">publisher</span> <span class="p">=</span> <span class="s">{ACM}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Qiuyang Mang, Runyuan He, Suyang Zhong, Xiaoxuan Liu, Huanchen Zhang, Alvin Cheung</name></author><category term="research"/><category term="database"/><category term="testing"/><category term="LLM"/><category term="DBMS"/><category term="SQL"/><summary type="html"><![CDATA[We present Argus, a novel framework that uses LLMs to automatically discover test oracles for DBMS testing — finding 41 previously unknown bugs across 5 widely-used databases. Accepted at SIGMOD 2026.]]></summary></entry></feed>